---
title: Transport Layer
description: Robust HTTP and WebSocket transport layers with advanced retry logic and performance monitoring.
---

# Transport Layer

The **Transport** module (`@connectorkit/sdk/transports`) provides robust HTTP and WebSocket transport layers with advanced retry logic, timeout handling, and performance monitoring.

## HTTP Transport

The HTTP transport handles all RPC communication with intelligent retry strategies and error recovery.

### Basic Usage

```typescript
import { createHttpTransport } from '@connectorkit/sdk/transports'

const transport = createHttpTransport({
  url: 'https://api.devnet.solana.com'
})

// Make RPC calls
const result = await transport.request({
  method: 'getBalance',
  params: ['4fYNw3dojWmQ4dUQFNUTcgd6fj6vKWUvkEvPEqKK5dL']
})
```

### Advanced Configuration

```typescript
import { createHttpTransport } from '@connectorkit/sdk/transports'

const transport = createHttpTransport({
  url: 'https://api.mainnet-beta.solana.com',
  
  // Custom headers (for authentication, etc.)
  headers: {
    'Authorization': 'Bearer your-token',
    'X-API-Key': 'your-api-key'
  },
  
  // Request timeout (default: 15 seconds)
  timeoutMs: 10000,
  
  // Retry configuration
  retry: {
    attempts: 5,
    strategy: 'exponential',
    baseDelayMs: 500,
    maxDelayMs: 30000,
    jitter: true
  }
})
```

## Retry Strategies

The transport supports multiple retry strategies to handle network failures and rate limiting.

### Exponential Backoff (Recommended)

```typescript
const transport = createHttpTransport({
  url: rpcUrl,
  retry: {
    attempts: 3,
    strategy: 'exponential', // 500ms, 1s, 2s, 4s...
    baseDelayMs: 500,
    maxDelayMs: 30000,
    jitter: true // Add randomness to prevent thundering herd
  }
})
```

### Linear Backoff

```typescript
const transport = createHttpTransport({
  url: rpcUrl,
  retry: {
    attempts: 3,
    strategy: 'linear', // 500ms, 1s, 1.5s, 2s...
    baseDelayMs: 500,
    maxDelayMs: 10000
  }
})
```

### Custom Retry Logic

```typescript
import { computeBackoffDelay } from '@connectorkit/sdk/transports'

// Custom delay calculation
const customDelay = computeBackoffDelay(attempt, {
  attempts: 5,
  strategy: 'exponential',
  baseDelayMs: 1000,
  maxDelayMs: 60000,
  jitter: true
})
```

## Request Lifecycle Monitoring

Monitor request performance and debug issues with lifecycle hooks.

### Basic Monitoring

```typescript
const transport = createHttpTransport({
  url: rpcUrl,
  onRequest: ({ id, method, url }) => {
    console.log(`üöÄ Request ${id}: ${method} to ${url}`)
  },
  
  onResponse: ({ id, ms, url }) => {
    console.log(`‚úÖ Response ${id}: ${ms}ms from ${url}`)
  },
  
  onError: ({ id, error, url }) => {
    console.error(`‚ùå Error ${id}: ${error} from ${url}`)
  }
})
```

### Performance Tracking

```typescript
class PerformanceMonitor {
  private metrics = new Map<string, number[]>()
  
  createTransport(url: string) {
    return createHttpTransport({
      url,
      onResponse: ({ method, ms }) => {
        // Track response times by method
        const times = this.metrics.get(method) || []
        times.push(ms)
        this.metrics.set(method, times)
      }
    })
  }
  
  getAverageResponseTime(method: string): number {
    const times = this.metrics.get(method) || []
    return times.reduce((sum, time) => sum + time, 0) / times.length
  }
  
  getStats() {
    const stats: Record<string, any> = {}
    
    for (const [method, times] of this.metrics.entries()) {
      stats[method] = {
        count: times.length,
        average: this.getAverageResponseTime(method),
        min: Math.min(...times),
        max: Math.max(...times)
      }
    }
    
    return stats
  }
}

const monitor = new PerformanceMonitor()
const transport = monitor.createTransport('https://api.devnet.solana.com')
```

## Error Handling

The transport automatically handles common RPC errors and provides detailed error information.

### Automatic Error Classification

```typescript
try {
  const result = await transport.request({
    method: 'getBalance',
    params: ['invalid-address']
  })
} catch (error) {
  if (error.message.includes('HTTP 429')) {
    // Rate limited - automatic retry will handle this
    console.log('Rate limited, retrying...')
  } else if (error.message.includes('HTTP 500')) {
    // Server error - may be retryable
    console.log('Server error, retrying...')
  } else {
    // Client error (400) - probably not retryable
    console.error('Client error:', error.message)
  }
}
```

### Custom Error Handling

```typescript
const transport = createHttpTransport({
  url: rpcUrl,
  onError: ({ id, error, url }) => {
    // Log to monitoring service
    if (error.message.includes('429')) {
      analytics.track('RPC_Rate_Limited', { url, id })
    } else if (error.message.includes('timeout')) {
      analytics.track('RPC_Timeout', { url, id })
    }
    
    // Alert on critical errors
    if (error.message.includes('500')) {
      alerting.notify('RPC server error', { error, url })
    }
  }
})
```

## Request Cancellation

Support for aborting long-running requests.

### Basic Cancellation

```typescript
const controller = new AbortController()

// Cancel request after 5 seconds
setTimeout(() => controller.abort(), 5000)

try {
  const result = await transport.request({
    method: 'getBalance',
    params: ['4fYNw3dojWmQ4dUQFNUTcgd6fj6vKWUvkEvPEqKK5dL']
  }, {
    signal: controller.signal
  })
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Request was cancelled')
  }
}
```

### React Integration

```tsx
import { useEffect, useRef } from 'react'

function useRpcCall(method: string, params: any[]) {
  const abortController = useRef<AbortController>()
  
  useEffect(() => {
    abortController.current = new AbortController()
    
    return () => {
      abortController.current?.abort()
    }
  }, [method, params])
  
  const makeRequest = async () => {
    return transport.request(
      { method, params },
      { signal: abortController.current?.signal }
    )
  }
  
  return makeRequest
}
```

## Transport Types

### Request/Response Types

```typescript
export interface JsonRpcRequest {
  id?: string | number
  method: string
  params?: unknown[] | Record<string, unknown>
}

export interface TransportRequestOptions {
  signal?: AbortSignal
  commitment?: 'processed' | 'confirmed' | 'finalized'
  onRequest?: (info: { id: string; method: string; url?: string }) => void
  onResponse?: (info: { id: string; ms: number; url?: string }) => void
  onError?: (info: { id: string; error: unknown; url?: string }) => void
  debug?: boolean
}
```

### Transport Interface

```typescript
export interface Transport {
  /** Unique identifier for debugging/metrics */
  id: string
  
  /** Optional current URL (for HTTP/WebSocket transports) */
  url?: string
  
  request<T = unknown>(
    req: JsonRpcRequest,
    opts?: TransportRequestOptions
  ): Promise<T>
}
```

### Retry Configuration

```typescript
export interface RetryConfig {
  attempts: number
  strategy: 'exponential' | 'linear'
  baseDelayMs?: number
  maxDelayMs?: number
  jitter?: boolean
}
```

## Best Practices

### Connection Pooling

```typescript
// ‚úÖ Good - Reuse transport instances
const transport = createHttpTransport({ url: rpcUrl })

async function makeMultipleCalls() {
  const results = await Promise.all([
    transport.request({ method: 'getBalance', params: [address1] }),
    transport.request({ method: 'getBalance', params: [address2] }),
    transport.request({ method: 'getBalance', params: [address3] })
  ])
}

// ‚ùå Bad - Creating new transport for each call
async function getBalnce(address: string) {
  const transport = createHttpTransport({ url: rpcUrl }) // Expensive!
  return transport.request({ method: 'getBalance', params: [address] })
}
```

### Error Recovery

```typescript
// ‚úÖ Good - Configure appropriate retry strategy
const transport = createHttpTransport({
  url: rpcUrl,
  retry: {
    attempts: 3,
    strategy: 'exponential',
    baseDelayMs: 500,
    maxDelayMs: 10000,
    jitter: true
  }
})

// ‚ùå Bad - No retry strategy
const transport = createHttpTransport({
  url: rpcUrl
  // No retry configuration - fails immediately on network issues
})
```

### Timeout Configuration

```typescript
// ‚úÖ Good - Appropriate timeout for your use case
const transport = createHttpTransport({
  url: rpcUrl,
  timeoutMs: 10000, // 10 seconds for most RPC calls
  retry: { attempts: 3, strategy: 'exponential' }
})

// For time-sensitive operations
const fastTransport = createHttpTransport({
  url: rpcUrl,
  timeoutMs: 3000, // 3 seconds
  retry: { attempts: 2, strategy: 'linear' }
})
```

### Monitoring and Debugging

```typescript
// ‚úÖ Good - Monitor performance in production
const transport = createHttpTransport({
  url: rpcUrl,
  onResponse: ({ method, ms }) => {
    // Track slow queries
    if (ms > 5000) {
      console.warn(`Slow RPC call: ${method} took ${ms}ms`)
    }
  },
  onError: ({ method, error }) => {
    // Log errors for monitoring
    logger.error('RPC Error', { method, error })
  }
})
```

## Next Steps

- **[Core](/docs/hooks/core)** - RPC connection management
- **[Utils](/docs/hooks/utils)** - Helper utilities and cluster detection
- **[Client](/docs/hooks/client)** - Server-side client implementation
