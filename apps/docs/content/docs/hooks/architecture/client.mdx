---
title: Client API
description: Server-side API for building backends, trading bots, and scripts with zero React dependencies.
---

# Client API

The **Client** module (`@connectorkit/sdk/client`) provides a server-side API for building backends, trading bots, and scripts. It has **zero React dependencies** and is optimized for Node.js environments.

## Key Features

- **Zero React Dependencies**: Perfect for servers, APIs, and scripts
- **Lightweight**: ~30KB bundle size
- **TypeScript First**: Full type safety for server environments
- **Production Ready**: Built-in error handling and retry logic

## Basic Usage

### Creating a Client

```typescript
import { createClient } from '@connectorkit/sdk/client'

const client = createClient({
  cluster: 'mainnet',
  rpcUrl: 'https://api.mainnet-beta.solana.com',
  commitment: 'confirmed'
})
```

### Getting Account Balance

```typescript
const balance = await client.getBalance('4fYNw3dojWmQ4dUQFNUTcgd6fj6vKWUvkEvPEqKK5dL')
console.log(`Balance: ${balance} lamports`) // Balance: 1000000000 lamports
```

## Configuration Options

### Basic Configuration

```typescript
interface ClientConfig {
  cluster?: 'mainnet' | 'devnet' | 'testnet' | 'localnet'
  rpcUrl?: string
  commitment?: 'processed' | 'confirmed' | 'finalized'
}

const client = createClient({
  cluster: 'devnet',
  commitment: 'finalized'
})
```

### Custom RPC Endpoint

```typescript
const client = createClient({
  rpcUrl: 'https://your-custom-rpc.com',
  commitment: 'confirmed'
})
```

## Use Cases

### API Routes (Next.js)

```typescript
// pages/api/balance/[address].ts
import { createClient } from '@connectorkit/sdk/client'
import type { NextApiRequest, NextApiResponse } from 'next'

const client = createClient({
  cluster: 'mainnet',
  commitment: 'confirmed'
})

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { address } = req.query
  
  try {
    const balance = await client.getBalance(address as string)
    res.status(200).json({ 
      balance: balance.toString(),
      balanceSOL: Number(balance) / 1e9
    })
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch balance' })
  }
}
```

### Serverless Functions (Vercel)

```typescript
// api/wallet-info.ts
import { createClient } from '@connectorkit/sdk/client'
import type { VercelRequest, VercelResponse } from '@vercel/node'

const client = createClient({
  rpcUrl: process.env.SOLANA_RPC_URL,
  commitment: 'confirmed'
})

export default async function handler(
  req: VercelRequest,
  res: VercelResponse
) {
  const { address } = req.query
  
  const balance = await client.getBalance(address as string)
  
  res.json({
    address,
    balance: balance.toString(),
    network: 'mainnet'
  })
}
```

### Trading Bots

```typescript
import { createClient } from '@connectorkit/sdk/client'

class SolanaTradingBot {
  private client = createClient({
    rpcUrl: process.env.SOLANA_RPC_URL,
    commitment: 'confirmed'
  })
  
  async checkBalance(address: string) {
    const balance = await this.client.getBalance(address)
    return Number(balance) / 1e9 // Convert to SOL
  }
  
  async monitorAccount(address: string) {
    setInterval(async () => {
      const balance = await this.checkBalance(address)
      console.log(`Account ${address}: ${balance} SOL`)
      
      if (balance > 10) {
        await this.executeTrade(address)
      }
    }, 5000)
  }
  
  private async executeTrade(address: string) {
    // Trading logic here
    console.log('Executing trade for', address)
  }
}

const bot = new SolanaTradingBot()
bot.monitorAccount('4fYNw3dojWmQ4dUQFNUTcgd6fj6vKWUvkEvPEqKK5dL')
```

### Data Analytics Scripts

```typescript
import { createClient } from '@connectorkit/sdk/client'

async function analyzeWallets(addresses: string[]) {
  const client = createClient({ cluster: 'mainnet' })
  
  const results = await Promise.all(
    addresses.map(async (address) => {
      try {
        const balance = await client.getBalance(address)
        return {
          address,
          balance: Number(balance),
          balanceSOL: Number(balance) / 1e9,
          status: 'active'
        }
      } catch (error) {
        return {
          address,
          balance: 0,
          balanceSOL: 0,
          status: 'error',
          error: error.message
        }
      }
    })
  )
  
  // Calculate statistics
  const totalBalance = results.reduce((sum, r) => sum + r.balanceSOL, 0)
  const activeWallets = results.filter(r => r.status === 'active').length
  
  console.log('Analysis Results:')
  console.log(`Total Wallets: ${addresses.length}`)
  console.log(`Active Wallets: ${activeWallets}`)
  console.log(`Total Balance: ${totalBalance.toFixed(4)} SOL`)
  
  return results
}

// Usage
const walletAddresses = [
  '4fYNw3dojWmQ4dUQFNUTcgd6fj6vKWUvkEvPEqKK5dL',
  '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU'
]

analyzeWallets(walletAddresses)
```

## Client Interface

```typescript
export interface SolanaClient {
  getBalance(address: string | Address): Promise<bigint>
  // More methods coming in future releases:
  // getAccountInfo(address: string | Address): Promise<AccountInfo>
  // getMultipleAccounts(addresses: (string | Address)[]): Promise<AccountInfo[]>
  // sendTransaction(transaction: Transaction): Promise<string>
}
```

## Error Handling

The client automatically handles common errors and provides retry logic:

```typescript
import { createClient } from '@connectorkit/sdk/client'

const client = createClient({
  rpcUrl: 'https://api.mainnet-beta.solana.com'
})

try {
  const balance = await client.getBalance(invalidAddress)
} catch (error) {
  if (error.message.includes('Invalid address')) {
    console.error('Address format is invalid')
  } else if (error.message.includes('rate limit')) {
    console.error('Rate limited, try again later')
  } else {
    console.error('Unexpected error:', error.message)
  }
}
```

## Environment Configuration

### Environment Variables

```bash
# .env
SOLANA_RPC_URL=https://your-rpc-endpoint.com
SOLANA_CLUSTER=mainnet
SOLANA_COMMITMENT=confirmed
```

```typescript
const client = createClient({
  rpcUrl: process.env.SOLANA_RPC_URL,
  cluster: process.env.SOLANA_CLUSTER as any,
  commitment: process.env.SOLANA_COMMITMENT as any
})
```

### Multiple Clients

```typescript
const mainnetClient = createClient({
  cluster: 'mainnet',
  commitment: 'finalized'
})

const devnetClient = createClient({
  cluster: 'devnet',
  commitment: 'confirmed'
})

// Use different clients for different purposes
const mainnetBalance = await mainnetClient.getBalance(address)
const devnetBalance = await devnetClient.getBalance(address)
```

## Performance Considerations

### Connection Reuse

```typescript
// ✅ Good - Create client once, reuse many times
const client = createClient({ cluster: 'mainnet' })

async function processMultipleAddresses(addresses: string[]) {
  return Promise.all(
    addresses.map(address => client.getBalance(address))
  )
}

// ❌ Bad - Creating new client for each call
async function getBalance(address: string) {
  const client = createClient({ cluster: 'mainnet' }) // Expensive!
  return client.getBalance(address)
}
```

### Batch Operations

```typescript
// Process multiple addresses efficiently
async function batchGetBalances(addresses: string[]) {
  const client = createClient({ cluster: 'mainnet' })
  
  // Process in chunks to avoid overwhelming the RPC
  const CHUNK_SIZE = 10
  const results: bigint[] = []
  
  for (let i = 0; i < addresses.length; i += CHUNK_SIZE) {
    const chunk = addresses.slice(i, i + CHUNK_SIZE)
    const chunkResults = await Promise.all(
      chunk.map(address => client.getBalance(address))
    )
    results.push(...chunkResults)
    
    // Small delay between chunks to be nice to RPC providers
    await new Promise(resolve => setTimeout(resolve, 100))
  }
  
  return results
}
```

## Next Steps

- **[Transports](/docs/hooks/transports)** - Configure HTTP transport settings
- **[Core](/docs/hooks/core)** - Advanced RPC management
- **[React Integration](/docs/hooks/react)** - Add React hooks to your frontend
