---
title: "useStakeAccount"
description: "Create and manage Solana stake accounts with customizable staker, withdrawer, and payer configurations."
---

## Overview

The `useStakeAccount` hook provides functionality to create Solana stake accounts with customizable staker, withdrawer, and payer configurations. This hook handles the transaction building, signing, and confirmation process for stake account creation. Note that this is a basic implementation that creates the foundation for staking - full staking functionality (initialize stake, delegate, etc.) will be added in future iterations.

## Usage

```tsx
import { useStakeAccount } from '@arc/solana'

function StakeAccountCreator() {
  const { createStakeAccount, isLoading, error, data } = useStakeAccount()

  const handleCreateStake = async () => {
    try {
      const result = await createStakeAccount({
        amount: BigInt(1000000000), // 1 SOL in lamports
        staker: 'YourStakerAddress111111111111111111111111',
        withdrawer: 'YourWithdrawerAddress111111111111111111111'
      })
      
      console.log('Stake account created:', result.stakeAccount)
      console.log('Transaction signature:', result.signature)
    } catch (err) {
      console.error('Failed to create stake account:', err)
    }
  }

  return (
    <div>
      <button 
        onClick={handleCreateStake}
        disabled={isLoading}
      >
        {isLoading ? 'Creating...' : 'Create Stake Account'}
      </button>
      
      {error && <div>Error: {error.message}</div>}
      {data && <div>Stake account created: {data.stakeAccount}</div>}
    </div>
  )
}
```

## Copy Hook Code

```typescript
'use client'

import { useMutation } from '@tanstack/react-query'
import { useEffect } from 'react'
import { useArcClient } from '../core/arc-client-provider'
import { getSharedRpc, getSharedWebSocket, releaseRpcConnection } from '../core/rpc-manager'
import type { Transport } from '../transports/types'
import { 
  sendAndConfirmTransactionFactory,
  createTransactionMessage,
  pipe,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  signTransactionMessageWithSigners,
  getSignatureFromTransaction,
  generateKeyPairSigner,
  address,
  type Address,
  type TransactionSigner,
  type Instruction
} from '@solana/kit'
import { 
  getCreateAccountInstruction,
  SYSTEM_PROGRAM_ADDRESS
} from '@solana-program/system'

// Note: This is a basic implementation. Full staking would require @solana-program/stake
// For now, we'll implement basic stake account creation as a foundation

export interface CreateStakeAccountOptions {
  amount: bigint 
  staker?: string | Address
  withdrawer?: string | Address
  payer?: string | Address
}

export interface StakeAccountResult {
  signature: string
  stakeAccount: Address
  amount: bigint
  staker: Address
  withdrawer: Address
  payer: Address
  blockTime?: number
  slot?: number
}

export interface UseStakeAccountReturn {
  createStakeAccount: (options: CreateStakeAccountOptions) => Promise<StakeAccountResult>
  isLoading: boolean
  error: Error | null
  data: StakeAccountResult | null
  reset: () => void
}

export function useStakeAccount(): UseStakeAccountReturn {
  const { wallet, network } = useArcClient()
  
  useEffect(() => {
    return () => {
      releaseRpcConnection(network.rpcUrl)
    }
  }, [network.rpcUrl])
  
  const mutation = useMutation({
    mutationFn: async (options: CreateStakeAccountOptions): Promise<StakeAccountResult> => {
      const { 
        amount,
        staker: optionsStaker,
        withdrawer: optionsWithdrawer,
        payer: optionsPayer
      } = options
      
      const stakerAddress = optionsStaker || wallet.address
      const withdrawerAddress = optionsWithdrawer || wallet.address
      const payerAddress = optionsPayer || wallet.address
      
      if (!stakerAddress) {
        throw new Error('No staker address provided and no wallet connected')
      }
      
      if (!withdrawerAddress) {
        throw new Error('No withdrawer address provided and no wallet connected')
      }
      
      if (!payerAddress) {
        throw new Error('No payer address provided and no wallet connected')
      }
      
      if (!wallet.signer) {
        throw new Error('Wallet not connected or no signer available')
      }
      
      
      
      const rpc = getSharedRpc(network.rpcUrl)
      const rpcSubscriptions = getSharedWebSocket(network.rpcUrl)
      const transport = (useArcClient() as any).config.transport as Transport
      const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc: rpc as any, rpcSubscriptions: rpcSubscriptions as any })
      
      const stakeAccount = await generateKeyPairSigner()
      
      
      const stakeAccountSpace = BigInt(200)
      
      const stakeAccountRent: any = await transport.request(
        { method: 'getMinimumBalanceForRentExemption', params: [stakeAccountSpace] }
      )
      
      
      const totalAmount = stakeAccountRent + amount
      
      
      const { value: latestBlockhash }: any = await transport.request(
        { method: 'getLatestBlockhash', params: [] }
      )
      
      
      // Build instruction to create stake account
      // Note: This creates a basic account. Full staking requires additional instructions
      // that would be added in future iterations (initialize stake, delegate, etc.)
      const createAccountInstruction = getCreateAccountInstruction({
        payer: wallet.signer as TransactionSigner,
        newAccount: stakeAccount,
        lamports: totalAmount,
        space: stakeAccountSpace,
        programAddress: SYSTEM_PROGRAM_ADDRESS, // Basic account creation
      })
      
      
      
      const transactionMessage = pipe(
        createTransactionMessage({ version: 0 }),
        tx => setTransactionMessageFeePayerSigner(wallet.signer as TransactionSigner, tx),
        tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
        tx => appendTransactionMessageInstructions([createAccountInstruction], tx),
      )
      
      
      
      const signedTransaction = await signTransactionMessageWithSigners(transactionMessage)
      const signature = getSignatureFromTransaction(signedTransaction)
      
      
      
      await sendAndConfirmTransaction(signedTransaction, { 
        commitment: 'confirmed',
        skipPreflight: false
      })
      
      
      
      const newAccount: any = await transport.request(
        { method: 'getAccountInfo', params: [stakeAccount.address] }
      )
      if (!newAccount.value) {
        throw new Error('Stake account creation failed - account not found after transaction')
      }
      
      
      
      const result: StakeAccountResult = {
        signature,
        stakeAccount: stakeAccount.address,
        amount,
        staker: address(stakerAddress),
        withdrawer: address(withdrawerAddress),
        payer: address(payerAddress)
      }
      
      return result
    },
    onSuccess: () => {},
    onError: () => {}
  })

  return {
    createStakeAccount: mutation.mutateAsync,
    isLoading: mutation.isPending,
    error: mutation.error,
    data: mutation.data || null,
    reset: mutation.reset
  }
}
```

## Parameters

The `createStakeAccount` function accepts an options object with the following properties:

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `amount` | `bigint` | **Required** | Amount of lamports to stake (excluding rent exemption) |
| `staker` | `string \| Address` | Connected wallet address | Address that will have staking authority |
| `withdrawer` | `string \| Address` | Connected wallet address | Address that will have withdrawal authority |
| `payer` | `string \| Address` | Connected wallet address | Address that will pay for the transaction fees |

## Return Value

The hook returns an object with the following properties:

| Property | Type | Description |
|----------|------|-------------|
| `createStakeAccount` | `(options: CreateStakeAccountOptions) => Promise<StakeAccountResult>` | Function to create a stake account |
| `isLoading` | `boolean` | Whether a stake account creation is in progress |
| `error` | `Error \| null` | Error object if the operation failed |
| `data` | `StakeAccountResult \| null` | Result of the last successful operation |
| `reset` | `() => void` | Function to reset the mutation state |

### StakeAccountResult Type

```typescript
interface StakeAccountResult {
  signature: string      // Transaction signature
  stakeAccount: Address  // Address of the created stake account
  amount: bigint        // Amount staked (in lamports)
  staker: Address       // Staker authority address
  withdrawer: Address   // Withdrawer authority address  
  payer: Address        // Payer address
  blockTime?: number    // Block time of confirmation
  slot?: number         // Slot of confirmation
}
```

## Example

```tsx
import { useStakeAccount } from '@arc/solana'
import { useState } from 'react'

function StakeAccountManager() {
  const { createStakeAccount, isLoading, error, data, reset } = useStakeAccount()
  const [amount, setAmount] = useState('')
  const [customStaker, setCustomStaker] = useState('')
  const [customWithdrawer, setCustomWithdrawer] = useState('')

  const handleCreateStakeAccount = async () => {
    try {
      const amountLamports = BigInt(Math.floor(parseFloat(amount) * 1e9)) // Convert SOL to lamports
      
      const options: CreateStakeAccountOptions = {
        amount: amountLamports,
        ...(customStaker && { staker: customStaker }),
        ...(customWithdrawer && { withdrawer: customWithdrawer })
      }

      const result = await createStakeAccount(options)
      console.log('Stake account created successfully:', result)
    } catch (err) {
      console.error('Failed to create stake account:', err)
    }
  }

  const handleReset = () => {
    reset()
    setAmount('')
    setCustomStaker('')
    setCustomWithdrawer('')
  }

  return (
    <div className="max-w-2xl mx-auto p-6 space-y-6">
      <div className="flex items-center justify-between">
        <h2 className="text-2xl font-bold">Create Stake Account</h2>
        {data && (
          <button 
            onClick={handleReset}
            className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700"
          >
            Reset
          </button>
        )}
      </div>

      {!data ? (
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Stake Amount (SOL)
            </label>
            <input
              type="number"
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="1.0"
              min="0"
              step="0.1"
            />
            <p className="text-sm text-gray-500 mt-1">
              Minimum recommended: 0.1 SOL (plus rent exemption)
            </p>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Custom Staker Address (Optional)
            </label>
            <input
              type="text"
              value={customStaker}
              onChange={(e) => setCustomStaker(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Leave empty to use connected wallet"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Custom Withdrawer Address (Optional)
            </label>
            <input
              type="text"
              value={customWithdrawer}
              onChange={(e) => setCustomWithdrawer(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Leave empty to use connected wallet"
            />
          </div>

          <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <h3 className="text-blue-800 font-semibold text-sm">Note</h3>
            <p className="text-blue-700 text-sm mt-1">
              This creates a basic stake account. Full staking functionality (initialize stake, delegate to validators, etc.) 
              will be added in future iterations when @solana-program/stake becomes available.
            </p>
          </div>

          <button
            onClick={handleCreateStakeAccount}
            disabled={isLoading || !amount || parseFloat(amount) <= 0}
            className="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
          >
            {isLoading ? 'Creating Stake Account...' : 'Create Stake Account'}
          </button>

          {error && (
            <div className="bg-red-50 border border-red-200 rounded-lg p-4">
              <h3 className="text-red-800 font-semibold">Error</h3>
              <p className="text-red-600 text-sm">{error.message}</p>
            </div>
          )}
        </div>
      ) : (
        <div className="bg-green-50 border border-green-200 rounded-lg p-6">
          <h3 className="text-green-800 font-semibold text-lg mb-4">
            Stake Account Created Successfully! ðŸŽ‰
          </h3>
          
          <div className="space-y-3">
            <div>
              <label className="text-sm font-medium text-gray-600">Transaction Signature</label>
              <p className="font-mono text-sm break-all bg-white p-2 rounded border">
                {data.signature}
              </p>
            </div>
            
            <div>
              <label className="text-sm font-medium text-gray-600">Stake Account Address</label>
              <p className="font-mono text-sm break-all bg-white p-2 rounded border">
                {data.stakeAccount}
              </p>
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="text-sm font-medium text-gray-600">Amount Staked</label>
                <p className="text-lg font-semibold">
                  {(Number(data.amount) / 1e9).toFixed(9)} SOL
                </p>
              </div>
              
              <div>
                <label className="text-sm font-medium text-gray-600">Staker Authority</label>
                <p className="font-mono text-xs break-all">
                  {data.staker}
                </p>
              </div>
              
              <div>
                <label className="text-sm font-medium text-gray-600">Withdrawer Authority</label>
                <p className="font-mono text-xs break-all">
                  {data.withdrawer}
                </p>
              </div>
              
              <div>
                <label className="text-sm font-medium text-gray-600">Payer</label>
                <p className="font-mono text-xs break-all">
                  {data.payer}
                </p>
              </div>
            </div>
          </div>

          <div className="mt-4 pt-4 border-t border-green-200">
            <p className="text-green-700 text-sm">
              <strong>Next Steps:</strong> Your stake account has been created but is not yet delegated to a validator. 
              Full staking delegation features will be available in future updates.
            </p>
          </div>
        </div>
      )}
    </div>
  )
}

// Advanced example with error handling and validation
function AdvancedStakeCreator() {
  const { createStakeAccount, isLoading, error, data, reset } = useStakeAccount()
  const [formData, setFormData] = useState({
    amount: '',
    staker: '',
    withdrawer: '',
    useCustomAuthorities: false
  })

  const validateForm = () => {
    const amount = parseFloat(formData.amount)
    if (!amount || amount <= 0) {
      return 'Please enter a valid amount'
    }
    if (amount < 0.01) {
      return 'Minimum amount is 0.01 SOL'
    }
    return null
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    const validationError = validateForm()
    if (validationError) {
      alert(validationError)
      return
    }

    try {
      const options: CreateStakeAccountOptions = {
        amount: BigInt(Math.floor(parseFloat(formData.amount) * 1e9))
      }

      if (formData.useCustomAuthorities) {
        if (formData.staker) options.staker = formData.staker
        if (formData.withdrawer) options.withdrawer = formData.withdrawer
      }

      await createStakeAccount(options)
    } catch (err) {
      console.error('Stake account creation failed:', err)
    }
  }

  return (
    <div className="max-w-md mx-auto p-6">
      <h2 className="text-xl font-bold mb-4">Advanced Stake Account Creator</h2>
      
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">Amount (SOL)</label>
          <input
            type="number"
            value={formData.amount}
            onChange={(e) => setFormData({...formData, amount: e.target.value})}
            className="w-full px-3 py-2 border rounded-md"
            required
            min="0.01"
            step="0.01"
          />
        </div>

        <div>
          <label className="flex items-center space-x-2">
            <input
              type="checkbox"
              checked={formData.useCustomAuthorities}
              onChange={(e) => setFormData({...formData, useCustomAuthorities: e.target.checked})}
            />
            <span className="text-sm">Use custom authorities</span>
          </label>
        </div>

        {formData.useCustomAuthorities && (
          <>
            <div>
              <label className="block text-sm font-medium mb-1">Custom Staker</label>
              <input
                type="text"
                value={formData.staker}
                onChange={(e) => setFormData({...formData, staker: e.target.value})}
                className="w-full px-3 py-2 border rounded-md text-sm"
                placeholder="Staker address"
              />
            </div>

            <div>
              <label className="block text-sm font-medium mb-1">Custom Withdrawer</label>
              <input
                type="text"
                value={formData.withdrawer}
                onChange={(e) => setFormData({...formData, withdrawer: e.target.value})}
                className="w-full px-3 py-2 border rounded-md text-sm"
                placeholder="Withdrawer address"
              />
            </div>
          </>
        )}

        <button
          type="submit"
          disabled={isLoading}
          className="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400"
        >
          {isLoading ? 'Creating...' : 'Create Stake Account'}
        </button>
      </form>

      {error && (
        <div className="mt-4 p-3 bg-red-50 border border-red-200 rounded text-red-600 text-sm">
          {error.message}
        </div>
      )}

      {data && (
        <div className="mt-4 p-3 bg-green-50 border border-green-200 rounded">
          <p className="text-green-800 font-semibold text-sm">Success!</p>
          <p className="text-green-700 text-xs font-mono break-all">
            {data.stakeAccount}
          </p>
          <button 
            onClick={reset}
            className="mt-2 text-xs text-blue-600 hover:text-blue-800"
          >
            Create Another
          </button>
        </div>
      )}
    </div>
  )
}
```

This example demonstrates comprehensive usage of the `useStakeAccount` hook with form validation, custom authorities, and proper error handling.