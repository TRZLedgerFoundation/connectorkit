---
title: useTokenAccount
description: Hook to fetch and monitor individual token account information
---

# useTokenAccount

The `useTokenAccount` hook provides functionality to fetch and monitor a specific token account by mint and owner. It automatically finds the associated token account (ATA) and provides real-time balance and state information.

## Usage

### Direct Import
```tsx
import { useTokenAccount } from '@connectorkit/solana'
import { useWalletAddress } from '@connectorkit/solana'

function TokenAccountDisplay() {
  const { address } = useWalletAddress()
  const {
    tokenAccount,
    isLoading,
    error,
    associatedAddress
  } = useTokenAccount({
    mint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
    owner: address
  })

  if (isLoading) return <div>Loading token account...</div>
  if (error) return <div>Error: {error.message}</div>
  if (!tokenAccount) return <div>No token account found</div>

  return (
    <div>
      <h3>USDC Account</h3>
      <p>Balance: {tokenAccount.uiAmount} USDC</p>
      <p>Address: {tokenAccount.address}</p>
      <p>State: {tokenAccount.state}</p>
    </div>
  )
}
```

### Copy Hook Code
```tsx
'use client'

import { useQuery, useQueryClient } from '@tanstack/react-query'
import { useEffect, useCallback } from 'react'
import { useArcClient } from '../core/arc-client-provider'
import { releaseRpcConnection } from '../core/rpc-manager' // ðŸš€ PERFORMANCE FIX
import type { Transport } from '../transports/types'
import { 
  address,
  type Address
} from '@solana/kit'
import { TOKEN_PROGRAM_ADDRESS, findAssociatedTokenPda } from '@solana-program/token'
import { 
  type Schema, 
  type ValidationResult,
  safeValidate,
  prepareAccountDataForValidation
} from '../utils/schema-validation'
import { queryKeys } from '../utils/query-keys'

export interface TokenAccountInfo {
  address: Address
  mint: Address
  owner: Address
  amount: bigint
  decimals: number
  uiAmount: number
  uiAmountString: string
  state: 'initialized' | 'uninitialized' | 'frozen'
  isNative: boolean
  closeAuthority?: Address | null
  delegate?: Address | null
  delegatedAmount?: bigint
  lamports: bigint
  rentEpoch: number
}

export interface UseTokenAccountOptions<T = TokenAccountInfo> {
  mint: string | Address
  owner?: string | Address
  findAssociated?: boolean
  refreshInterval?: number
  enabled?: boolean
  onUpdate?: (tokenAccount: T) => void
  schema?: Schema<T>
  onValidationSuccess?: (data: T) => void
  onValidationError?: (error: Error) => void
}

export interface UseTokenAccountReturn<T = TokenAccountInfo> {
  tokenAccount: TokenAccountInfo | null
  data: T | null
  validation: ValidationResult<T> | null
  associatedAddress: Address | null
  isLoading: boolean
  error: Error | null
  refetch: () => void
  clear: () => void
}

/**
 * Hook to fetch and monitor a token account by mint and owner.
 * 
 * By default, it finds the associated token account (ATA) for the given mint/owner pair.
 * 
 * @example
 * ```tsx
 * const { tokenAccount, isLoading } = useTokenAccount({
 *   mint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
 *   owner: wallet.address
 * })
 * 
 * if (tokenAccount) {
 *   console.log(`Balance: ${tokenAccount.uiAmount} USDC`)
 * }
 * ```
 */
export function useTokenAccount<T = TokenAccountInfo>(options: UseTokenAccountOptions<T>): UseTokenAccountReturn<T> {
  const { wallet, network } = useArcClient()
  
  const queryClient = useQueryClient()
  
  useEffect(() => {
    return () => {
      releaseRpcConnection(network.rpcUrl)
    }
  }, [network.rpcUrl])
  
  const {
    mint,
    owner: optionsOwner,
    findAssociated = true,
    refreshInterval = 30000,
    enabled = true,
    onUpdate,
    schema,
    onValidationSuccess,
    onValidationError,
  } = options

  const validateData = useCallback((rawData: TokenAccountInfo): ValidationResult<T> | null => {
    if (!schema || !rawData) return null
    
    const preparedData = prepareAccountDataForValidation(rawData)
    const result = safeValidate(preparedData, schema)
    
    if (result.success && onValidationSuccess) {
      onValidationSuccess(result.data!)
    } else if (!result.success && onValidationError) {
      onValidationError(result.error!)
    }
    
    return result
  }, [schema, onValidationSuccess, onValidationError])

  const targetOwner = optionsOwner || wallet.address
  
  const associatedQueryKey = [...queryKeys.tokenAccount(targetOwner || undefined, mint || undefined), 'associated']
  const associatedQuery = useQuery({
    queryKey: associatedQueryKey,
    queryFn: async (): Promise<Address | null> => {
      if (!targetOwner || !findAssociated) return null
      
      const [ata] = await findAssociatedTokenPda({
        mint: address(mint),
        owner: address(targetOwner),
        tokenProgram: TOKEN_PROGRAM_ADDRESS,
      })
      return ata
    },
    enabled: enabled && !!targetOwner && !!mint && findAssociated,
    staleTime: 5 * 60 * 1000, // ATA addresses don't change - cache for 5 minutes
  })

  const tokenAccountAddress = associatedQuery.data
  const dataQueryKey = [...queryKeys.tokenAccount(targetOwner || undefined, mint || undefined), 'data', tokenAccountAddress, network.rpcUrl, schema ? 'schema' : 'raw']

  const { data: queryData, isLoading, error, refetch } = useQuery({
    networkMode: "offlineFirst",
    queryKey: dataQueryKey,
    queryFn: async ({ signal }): Promise<{ tokenAccount: TokenAccountInfo | null; validation: ValidationResult<T> | null }> => {
      if (!tokenAccountAddress) {
        throw new Error('No token account address computed')
      }
      
      const transport = (useArcClient() as any).config.transport as Transport
      
      // TODO: Future optimization - convert to base64 encoding with SPL token decoders
      // for better performance. Currently using jsonParsed for simplicity.
      const accountInfo: any = await transport.request(
        { method: 'getAccountInfo', params: [tokenAccountAddress, { encoding: 'jsonParsed' }] },
        { signal }
      )
      
      if (!accountInfo.value) {
        return { tokenAccount: null, validation: null }
      }
      
      if (!accountInfo.value.data || typeof accountInfo.value.data !== 'object' || !('parsed' in accountInfo.value.data)) {
        throw new Error('Invalid token account data format')
      }
      
      const parsed = accountInfo.value.data.parsed as any
      const info = parsed.info
      
      const result: TokenAccountInfo = {
        address: tokenAccountAddress,
        mint: address(info.mint),
        owner: address(info.owner),
        amount: BigInt(info.tokenAmount.amount),
        decimals: info.tokenAmount.decimals,
        uiAmount: info.tokenAmount.uiAmount || 0,
        uiAmountString: info.tokenAmount.uiAmountString || '0',
        state: info.state,
        isNative: info.isNative || false,
        closeAuthority: info.closeAuthority ? address(info.closeAuthority) : null,
        delegate: info.delegate ? address(info.delegate) : null,
        delegatedAmount: info.delegatedAmount ? BigInt(info.delegatedAmount.amount) : undefined,
        lamports: BigInt(accountInfo.value.lamports),
        rentEpoch: Number(accountInfo.value.rentEpoch) || 0
      }
      
      const validation = validateData(result)
      
      if (onUpdate) {
        if (validation?.success) {
          onUpdate(validation.data!)
        } else {
          onUpdate(result as T)
        }
      }
      
      return { tokenAccount: result, validation }
    },
    enabled: enabled && !!tokenAccountAddress && !!targetOwner,
    refetchInterval: refreshInterval,
    refetchOnWindowFocus: false,
    staleTime: 15_000,
    gcTime: 5 * 60_000,
    retry: 1,
    notifyOnChangeProps: ['data', 'error'],
  })
  
  const clear = useCallback(() => {
    queryClient.removeQueries({ queryKey: dataQueryKey })
    queryClient.removeQueries({ queryKey: associatedQueryKey })
  }, [queryClient, dataQueryKey, associatedQueryKey])

  return {
    tokenAccount: queryData?.tokenAccount || null,
    data: queryData?.validation?.success ? queryData.validation.data! : null,
    validation: queryData?.validation || null,
    associatedAddress: tokenAccountAddress || null,
    isLoading: associatedQuery.isLoading || isLoading,
    error: associatedQuery.error || error,
    refetch: () => {
      associatedQuery.refetch()
      refetch()
    },
    clear
  }
}
```

## Parameters

### UseTokenAccountOptions

- `mint: string | Address` - The mint address of the token (required)
- `owner?: string | Address` - The owner of the token account (defaults to connected wallet)
- `findAssociated?: boolean` - Whether to find the associated token account (default: true)
- `refreshInterval?: number` - How often to refresh the data in milliseconds (default: 30000)
- `enabled?: boolean` - Whether the query is enabled (default: true)
- `onUpdate?: (tokenAccount: T) => void` - Callback when account data updates
- `schema?: Schema<T>` - Schema for data validation
- `onValidationSuccess?: (data: T) => void` - Callback for successful validation
- `onValidationError?: (error: Error) => void` - Callback for validation errors

## Return Value

- `tokenAccount: TokenAccountInfo | null` - The token account information
- `data: T | null` - Validated data if schema is provided
- `validation: ValidationResult<T> | null` - Validation result if schema is provided
- `associatedAddress: Address | null` - The computed associated token account address
- `isLoading: boolean` - Whether the data is loading
- `error: Error | null` - Any error that occurred
- `refetch: () => void` - Function to manually refresh the data
- `clear: () => void` - Function to clear cached data

### TokenAccountInfo

- `address: Address` - The token account address
- `mint: Address` - The mint address
- `owner: Address` - The owner address
- `amount: bigint` - Raw token amount
- `decimals: number` - Number of decimals for the token
- `uiAmount: number` - User-friendly amount (adjusted for decimals)
- `uiAmountString: string` - String representation of the UI amount
- `state: 'initialized' | 'uninitialized' | 'frozen'` - Account state
- `isNative: boolean` - Whether this is a native SOL account
- `closeAuthority?: Address | null` - Close authority if set
- `delegate?: Address | null` - Delegate authority if set
- `delegatedAmount?: bigint` - Amount delegated if applicable
- `lamports: bigint` - Rent-exempt lamports in the account
- `rentEpoch: number` - Rent epoch

## Example

```tsx
import { useTokenAccount } from '@connectorkit/solana'
import { useWalletAddress } from '@connectorkit/solana'
import { useState } from 'react'

function TokenAccountViewer() {
  const { address: walletAddress } = useWalletAddress()
  const [mintAddress, setMintAddress] = useState('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v') // USDC

  const {
    tokenAccount,
    associatedAddress,
    isLoading,
    error,
    refetch,
    clear
  } = useTokenAccount({
    mint: mintAddress,
    owner: walletAddress,
    refreshInterval: 10000, // Refresh every 10 seconds
    onUpdate: (account) => {
      console.log('Token account updated:', account)
    }
  })

  const formatBalance = (account: typeof tokenAccount) => {
    if (!account) return '0'
    return account.uiAmount.toLocaleString(undefined, {
      minimumFractionDigits: 0,
      maximumFractionDigits: account.decimals
    })
  }

  return (
    <div style={{ padding: '20px', maxWidth: '600px' }}>
      <h3>Token Account Viewer</h3>
      
      <div style={{ marginBottom: '16px' }}>
        <label>
          Mint Address:
          <input
            type="text"
            value={mintAddress}
            onChange={(e) => setMintAddress(e.target.value)}
            placeholder="Enter token mint address"
            style={{ 
              width: '100%', 
              padding: '8px', 
              marginTop: '4px',
              fontSize: '14px',
              fontFamily: 'monospace'
            }}
          />
        </label>
      </div>

      <div style={{ marginBottom: '16px' }}>
        <button
          onClick={refetch}
          disabled={isLoading}
          style={{ marginRight: '8px', padding: '8px 16px' }}
        >
          {isLoading ? 'Loading...' : 'Refresh'}
        </button>
        <button
          onClick={clear}
          style={{ padding: '8px 16px' }}
        >
          Clear Cache
        </button>
      </div>

      {error && (
        <div style={{ 
          marginBottom: '16px',
          padding: '12px', 
          backgroundColor: '#ffebee', 
          border: '1px solid #f44336',
          borderRadius: '4px',
          color: '#d32f2f'
        }}>
          <strong>Error:</strong> {error.message}
        </div>
      )}

      {associatedAddress && (
        <div style={{ 
          marginBottom: '16px',
          padding: '12px', 
          backgroundColor: '#f5f5f5', 
          borderRadius: '4px'
        }}>
          <p><strong>Associated Token Account:</strong></p>
          <code style={{ wordBreak: 'break-all' }}>{associatedAddress}</code>
        </div>
      )}

      {tokenAccount ? (
        <div style={{ 
          padding: '16px', 
          backgroundColor: '#e8f5e8', 
          border: '1px solid #4CAF50',
          borderRadius: '4px'
        }}>
          <h4>Token Account Details</h4>
          
          <div style={{ display: 'grid', gap: '8px' }}>
            <p><strong>Balance:</strong> {formatBalance(tokenAccount)}</p>
            <p><strong>Raw Amount:</strong> {tokenAccount.amount.toString()}</p>
            <p><strong>Decimals:</strong> {tokenAccount.decimals}</p>
            <p><strong>State:</strong> 
              <span style={{ 
                marginLeft: '8px',
                padding: '2px 6px',
                backgroundColor: tokenAccount.state === 'initialized' ? '#4CAF50' : '#ff9800',
                color: 'white',
                borderRadius: '3px',
                fontSize: '12px'
              }}>
                {tokenAccount.state}
              </span>
            </p>
            <p><strong>Owner:</strong> 
              <code style={{ marginLeft: '8px' }}>{tokenAccount.owner}</code>
            </p>
            <p><strong>Mint:</strong> 
              <code style={{ marginLeft: '8px' }}>{tokenAccount.mint}</code>
            </p>
            
            {tokenAccount.delegate && (
              <p><strong>Delegate:</strong> 
                <code style={{ marginLeft: '8px' }}>{tokenAccount.delegate}</code>
              </p>
            )}
            
            {tokenAccount.delegatedAmount && (
              <p><strong>Delegated Amount:</strong> {tokenAccount.delegatedAmount.toString()}</p>
            )}
            
            {tokenAccount.closeAuthority && (
              <p><strong>Close Authority:</strong> 
                <code style={{ marginLeft: '8px' }}>{tokenAccount.closeAuthority}</code>
              </p>
            )}
            
            <p><strong>Rent Lamports:</strong> {tokenAccount.lamports.toString()}</p>
            <p><strong>Is Native:</strong> {tokenAccount.isNative ? 'Yes' : 'No'}</p>
          </div>
        </div>
      ) : !isLoading && !error ? (
        <div style={{ 
          padding: '16px', 
          backgroundColor: '#fff3e0', 
          border: '1px solid #ff9800',
          borderRadius: '4px'
        }}>
          <p>No token account found for this mint and owner combination.</p>
          <p><small>The account may not exist yet, or the mint address may be invalid.</small></p>
        </div>
      ) : null}
    </div>
  )
}
```

## Features

- **Automatic ATA Resolution**: Finds the associated token account address automatically
- **Real-time Updates**: Continuously monitors account changes with configurable intervals
- **Schema Validation**: Optional schema validation for custom data structures
- **Caching**: Intelligent caching with proper cache invalidation
- **Error Handling**: Comprehensive error handling with user-friendly messages
- **Manual Control**: Ability to manually refresh or clear cached data

## Use Cases

- **Wallet Balance Display**: Show token balances in wallet interfaces
- **Portfolio Tracking**: Monitor multiple token accounts for portfolio apps
- **Trading Interfaces**: Display real-time token balances for trading
- **Payment Systems**: Check account balances before processing payments

## Notes

- Returns `null` if the token account doesn't exist
- Automatically refreshes data at the specified interval (default: 30 seconds)
- The hook uses the associated token account (ATA) address by default
- Data is cached to reduce unnecessary network requests
- Schema validation is optional and useful for type-safe data handling