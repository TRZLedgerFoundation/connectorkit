---
title: useLatestBlockhash
description: Hook to get the latest blockhash and last valid block height for transaction creation
---

# useLatestBlockhash

The `useLatestBlockhash` hook fetches the latest blockhash and its last valid block height from the Solana blockchain. This is essential for creating transactions, as every Solana transaction must include a recent blockhash to prevent replay attacks and ensure transactions expire after a reasonable time.

## Usage

### Direct Import
```tsx
import { useLatestBlockhash } from '@connectorkit/solana'

function BlockhashDisplay() {
  const { blockhash, lastValidBlockHeight, isLoading, error } = useLatestBlockhash({
    refreshInterval: 10000
  })
  
  if (isLoading) return <div>Loading blockhash...</div>
  if (error) return <div>Error: {error.message}</div>
  
  return (
    <div>
      <p>Blockhash: {blockhash}</p>
      <p>Valid until block: {lastValidBlockHeight?.toString()}</p>
    </div>
  )
}
```

### Copy Hook Code
```tsx
'use client'

import { useQuery } from '@tanstack/react-query'
import { useArcClient } from '../core/arc-client-provider'
import type { Transport } from '../transports/types'
import { 
  ArcError,
  createNetworkError,
  type ArcErrorContext
} from '../core/error-handler'
import type { Blockhash } from '@solana/rpc-types'

export interface UseLatestBlockhashOptions {
  refreshInterval?: number
  enabled?: boolean
}

export interface UseLatestBlockhashReturn {
  blockhash: Blockhash | null
  lastValidBlockHeight: bigint | null
  isLoading: boolean
  error: ArcError | null
  refetch: () => void
}

export function useLatestBlockhash(options: UseLatestBlockhashOptions = {}): UseLatestBlockhashReturn {
  const { network } = useArcClient()
  
  const {
    refreshInterval = 10000,
    enabled = true,
  } = options

  const query = useQuery<{ blockhash: Blockhash; lastValidBlockHeight: bigint }, ArcError>({
    networkMode: "offlineFirst",
    queryKey: ['latestBlockhash', network.rpcUrl],
    queryFn: async ({ signal }) => {
      const context: ArcErrorContext = {
        operation: 'getLatestBlockhash',
        timestamp: Date.now(),
        rpcUrl: network.rpcUrl
      }

      try {
        const transport = (useArcClient() as any).config.transport as Transport
        const response: any = await transport.request(
          { method: 'getLatestBlockhash', params: [] },
          { signal }
        )
        return response?.value
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error)
        throw createNetworkError(
          `Failed to fetch latest blockhash: ${errorMessage}`,
          context,
          error as Error
        )
      }
    },
    enabled: enabled,
    refetchInterval: refreshInterval,
    refetchOnWindowFocus: false,
    staleTime: 5_000,
    gcTime: 5 * 60_000,
    retry: 1,
    notifyOnChangeProps: ['data', 'error', 'isLoading'],
  })

  return {
    blockhash: query.data?.blockhash ?? null,
    lastValidBlockHeight: query.data?.lastValidBlockHeight ?? null,
    isLoading: query.isLoading,
    error: query.error ?? null,
    refetch: query.refetch,
  }
}
```

## Parameters

- `refreshInterval?: number` - How often to refresh data in milliseconds (default: 10000)
- `enabled?: boolean` - Whether the query is enabled (default: true)

## Return Value

- `blockhash: Blockhash | null` - The latest blockhash string
- `lastValidBlockHeight: bigint | null` - The last block height where this blockhash is valid
- `isLoading: boolean` - Whether the blockhash is loading
- `error: ArcError | null` - Any error that occurred
- `refetch: () => void` - Function to manually refetch the latest blockhash

## Example

```tsx
import { useLatestBlockhash, useBlockHeight } from '@connectorkit/solana'
import { useEffect, useState } from 'react'

function BlockhashMonitor() {
  const {
    blockhash,
    lastValidBlockHeight,
    isLoading,
    error,
    refetch
  } = useLatestBlockhash({
    refreshInterval: 5000 // Update every 5 seconds
  })

  const { blockHeightNumber } = useBlockHeight()
  
  const [timeRemaining, setTimeRemaining] = useState<number | null>(null)
  const [isExpiring, setIsExpiring] = useState(false)

  useEffect(() => {
    if (lastValidBlockHeight && blockHeightNumber) {
      const remaining = Number(lastValidBlockHeight) - blockHeightNumber
      setTimeRemaining(remaining)
      setIsExpiring(remaining <= 32) // Warn when 32 blocks or less
    }
  }, [lastValidBlockHeight, blockHeightNumber])

  if (isLoading && !blockhash) {
    return (
      <div style={{ padding: '16px', textAlign: 'center' }}>
        <div>Loading latest blockhash...</div>
      </div>
    )
  }

  if (error) {
    return (
      <div style={{ padding: '16px', color: 'red' }}>
        <div>Error loading blockhash: {error.message}</div>
        <button onClick={() => refetch()}>Retry</button>
      </div>
    )
  }

  return (
    <div style={{ padding: '16px' }}>
      <h3>Latest Blockhash Monitor</h3>
      
      <div style={{ display: 'grid', gap: '12px', marginBottom: '16px' }}>
        <div style={{ 
          backgroundColor: '#f5f5f5', 
          padding: '16px', 
          borderRadius: '8px',
          display: 'grid',
          gap: '8px'
        }}>
          <h4 style={{ margin: 0 }}>Blockhash Info</h4>
          <div>
            <strong>Latest Blockhash:</strong>
            <div style={{ 
              fontFamily: 'monospace', 
              fontSize: '12px',
              wordBreak: 'break-all',
              padding: '8px',
              backgroundColor: '#eee',
              borderRadius: '4px',
              marginTop: '4px'
            }}>
              {blockhash}
            </div>
          </div>
          <div>
            <strong>Valid Until Block:</strong> {lastValidBlockHeight?.toString()}
          </div>
          <div>
            <strong>Current Block:</strong> {blockHeightNumber.toLocaleString()}
          </div>
        </div>

        {timeRemaining !== null && (
          <div style={{ 
            backgroundColor: isExpiring ? '#ffebee' : '#e8f5e8', 
            padding: '16px', 
            borderRadius: '8px',
            border: isExpiring ? '1px solid #f44336' : '1px solid #4caf50'
          }}>
            <h4 style={{ margin: 0, color: isExpiring ? '#d32f2f' : '#2e7d32' }}>
              Validity Status
            </h4>
            <div style={{ color: isExpiring ? '#d32f2f' : '#2e7d32' }}>
              <strong>Blocks Remaining:</strong> {timeRemaining}
            </div>
            <div style={{ fontSize: '12px', marginTop: '4px' }}>
              {isExpiring 
                ? '⚠️ Blockhash expiring soon! Transactions may fail.'
                : '✅ Blockhash is valid for transactions.'
              }
            </div>
            <div style={{ fontSize: '12px', color: '#666', marginTop: '4px' }}>
              Estimated time: ~{Math.round(timeRemaining * 0.4)} seconds
            </div>
          </div>
        )}

        <div style={{ 
          backgroundColor: '#f0f4ff', 
          padding: '16px', 
          borderRadius: '8px'
        }}>
          <h4 style={{ margin: 0 }}>Transaction Usage</h4>
          <div style={{ fontSize: '14px', color: '#555', marginTop: '8px' }}>
            Use this blockhash when creating transactions:
          </div>
          <pre style={{ 
            backgroundColor: '#eee',
            padding: '8px',
            borderRadius: '4px',
            fontSize: '12px',
            marginTop: '8px',
            overflow: 'auto'
          }}>
{`transaction.recentBlockhash = "${blockhash}"
// Transaction must be submitted before block ${lastValidBlockHeight?.toString()}`}
          </pre>
        </div>
      </div>

      <div style={{ display: 'flex', gap: '8px' }}>
        <button 
          onClick={() => refetch()}
          style={{
            padding: '8px 16px',
            backgroundColor: '#2196F3',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          Refresh Blockhash
        </button>
        
        <button 
          onClick={() => navigator.clipboard.writeText(blockhash || '')}
          disabled={!blockhash}
          style={{
            padding: '8px 16px',
            backgroundColor: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            opacity: blockhash ? 1 : 0.5
          }}
        >
          Copy Blockhash
        </button>
      </div>
    </div>
  )
}
```

## Blockhash System Overview

**What is a Blockhash?**
- A unique identifier for a recent block on the Solana blockchain
- Required in every transaction to prevent replay attacks
- Acts as a "proof of recency" for transactions

**Validity Period:**
- Blockhashes are valid for approximately 150 blocks (~60 seconds)
- After expiration, transactions using old blockhashes will be rejected
- `lastValidBlockHeight` tells you the exact block where it expires

**Transaction Lifecycle:**
1. Get latest blockhash
2. Create and sign transaction with blockhash
3. Submit transaction before blockhash expires
4. Network validates blockhash recency

## Use Cases

- **Transaction Creation**: Get fresh blockhash for new transactions
- **Wallet Applications**: Monitor blockhash freshness for pending transactions
- **DeFi Protocols**: Ensure transactions have valid blockhashes before submission
- **Transaction Builders**: Validate blockhash expiry before signing
- **Network Monitoring**: Track blockhash refresh rates and validity periods

## Best Practices

- **Refresh Frequently**: Update every 5-10 seconds for active applications
- **Check Expiry**: Validate blockhash hasn't expired before using
- **Handle Failures**: Retry with fresh blockhash if transaction fails due to expired blockhash
- **Batch Transactions**: Use same blockhash for multiple transactions created at once
- **Monitor Network**: Watch for network congestion affecting blockhash validity

## Notes

- Blockhashes expire after ~150 blocks (approximately 60 seconds)
- Default refresh interval is 10 seconds to ensure freshness
- Uses 5-second stale time to balance performance and accuracy
- Includes comprehensive error handling for network issues
- Essential for all transaction creation workflows
- Consider network conditions when timing transaction submissions