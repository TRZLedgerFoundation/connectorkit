---
title: useTokenAccountsByOwner
description: Hook to fetch all token accounts owned by a specific wallet address
---

# useTokenAccountsByOwner

The `useTokenAccountsByOwner` hook provides functionality to fetch all token accounts owned by a specific wallet address. This is useful for displaying a complete portfolio of tokens or getting an overview of all token holdings.

## Usage

### Direct Import
```tsx
import { useTokenAccountsByOwner } from '@arc/solana'
import { useWalletAddress } from '@arc/solana'

function TokenPortfolio() {
  const { address } = useWalletAddress()
  const {
    tokenAccounts,
    isLoading,
    error,
    refetch
  } = useTokenAccountsByOwner({
    owner: address,
    excludeZeroBalances: true
  })

  if (isLoading) return <div>Loading token accounts...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <div>
      <h3>My Token Portfolio</h3>
      {tokenAccounts?.map(account => (
        <div key={account.address}>
          <p>Mint: {account.mint}</p>
          <p>Balance: {account.amount.toString()}</p>
        </div>
      ))}
    </div>
  )
}
```

### Copy Hook Code
```tsx
'use client'

import { useQuery } from '@tanstack/react-query'
import { useArcClient } from '../core/arc-client-provider'
import type { Transport } from '../transports/types'
import { 
  ArcError,
  ArcErrorCode,
  createNetworkError,
  type ArcErrorContext
} from '../core/error-handler'
import { address, type Address } from '@solana/kit'

export interface UseTokenAccountsByOwnerOptions {
  owner?: Address | string
  mint?: Address
  programId?: Address
  refreshInterval?: number
  enabled?: boolean
  commitment?: 'processed' | 'confirmed' | 'finalized'
  encoding?: 'base58' | 'base64' | 'base64+zstd' | 'jsonParsed'
  excludeZeroBalances?: boolean
}

export interface TokenAccount {
  address: Address
  mint: Address
  owner: Address
  amount: bigint
  state: 'initialized' | 'uninitialized' | 'frozen'
  delegate?: Address
  delegatedAmount?: bigint
  closeAuthority?: Address
  isNative: boolean
  rentExemptReserve?: bigint
  createdAt?: Date
}

export interface UseTokenAccountsByOwnerReturn {
  tokenAccounts: TokenAccount[] | null
  isLoading: boolean
  error: ArcError | null
  refetch: () => void
  owner: string | null
}

const TOKEN_PROGRAM_ID = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'

export function useTokenAccountsByOwner(
  options: UseTokenAccountsByOwnerOptions = {}
): UseTokenAccountsByOwnerReturn {
  const { wallet, network } = useArcClient()
  
  const {
    owner: optionsOwner,
    mint,
    programId = TOKEN_PROGRAM_ID,
    refreshInterval = 30000,
    enabled = true,
    commitment = 'confirmed',
    encoding = 'jsonParsed',
    excludeZeroBalances = true,
  } = options

  const targetOwner = optionsOwner || wallet.address

  const query = useQuery<TokenAccount[], ArcError>({
    networkMode: "offlineFirst",
    queryKey: [
      'tokenAccountsByOwner', 
      network.rpcUrl, 
      targetOwner, 
      mint, 
      programId, 
      commitment, 
      encoding,
      excludeZeroBalances
    ],
    queryFn: async () => {
      const context: ArcErrorContext = {
        operation: 'getTokenAccountsByOwner',
        address: targetOwner || 'none',
        timestamp: Date.now(),
        rpcUrl: network.rpcUrl
      }

      if (!targetOwner) {
        throw new ArcError(
          'No owner address provided and no wallet connected',
          ArcErrorCode.WALLET_NOT_CONNECTED,
          context
        )
      }

      try {
        // Validate owner address
        let ownerAddress: Address
        try {
          ownerAddress = address(targetOwner)
        } catch (error) {
          throw new ArcError(
            `Invalid owner address format: ${targetOwner}`,
            ArcErrorCode.INVALID_ADDRESS,
            context,
            error as Error
          )
        }

        const transport = (useArcClient() as any).config.transport as Transport

        const filter = mint 
          ? { mint: address(mint) }
          : { programId: address(programId) }

        const rpcConfig = {
          commitment,
          encoding,
        }

        const response: any = await transport.request(
          { method: 'getTokenAccountsByOwner', params: [ownerAddress, filter, rpcConfig] }
        )

        const tokenAccounts: TokenAccount[] = (response.value as any[])
          .map((accountInfo: any) => {
            try {
              const accountAddress = address(accountInfo.pubkey)
              
              if (encoding === 'jsonParsed' && (accountInfo.account.data as any).parsed) {
                const parsed = (accountInfo.account.data as any).parsed
                const info = parsed.info
                
                const tokenAmount = BigInt(info.tokenAmount?.amount || '0')
                
                if (excludeZeroBalances && tokenAmount === 0n) {
                  return null
                }

                return {
                  address: accountAddress,
                  mint: address(info.mint),
                  owner: address(info.owner),
                  amount: tokenAmount,
                  state: info.state || 'initialized',
                  delegate: info.delegate ? address(info.delegate) : undefined,
                  delegatedAmount: info.delegatedAmount ? BigInt(info.delegatedAmount.amount) : undefined,
                  closeAuthority: info.closeAuthority ? address(info.closeAuthority) : undefined,
                  isNative: !!info.isNative,
                  rentExemptReserve: info.isNative ? BigInt(info.isNative) : undefined,
                } as TokenAccount
              } else {
                // Non-parsed token account data not yet supported
                return null
              }
            } catch (error) {
              return null
            }
          })
           .filter((account: any): account is TokenAccount => account !== null)
        return tokenAccounts

      } catch (error) {
        if (error instanceof ArcError) {
          throw error
        }
        
        const errorMessage = error instanceof Error ? error.message : String(error)
        throw createNetworkError(
          `Failed to fetch token accounts: ${errorMessage}`,
          context,
          error as Error
        )
      }
    },
    enabled: enabled && !!targetOwner,
    refetchInterval: refreshInterval,
    staleTime: 20000,
    notifyOnChangeProps: ['data', 'error', 'isLoading'],
  })

  return {
    tokenAccounts: query.data ?? null,
    isLoading: query.isLoading,
    error: query.error ?? null,
    refetch: query.refetch,
    owner: targetOwner,
  }
}
```

## Parameters

### UseTokenAccountsByOwnerOptions

- `owner?: Address | string` - The wallet address to fetch token accounts for (defaults to connected wallet)
- `mint?: Address` - Filter by specific mint address (optional)
- `programId?: Address` - Token program ID to filter by (default: SPL Token Program)
- `refreshInterval?: number` - How often to refresh the data in milliseconds (default: 30000)
- `enabled?: boolean` - Whether the query is enabled (default: true)
- `commitment?: 'processed' | 'confirmed' | 'finalized'` - Commitment level (default: 'confirmed')
- `encoding?: 'base58' | 'base64' | 'base64+zstd' | 'jsonParsed'` - Data encoding (default: 'jsonParsed')
- `excludeZeroBalances?: boolean` - Whether to exclude accounts with zero balance (default: true)

## Return Value

- `tokenAccounts: TokenAccount[] | null` - Array of token accounts
- `isLoading: boolean` - Whether the data is loading
- `error: ArcError | null` - Any error that occurred
- `refetch: () => void` - Function to manually refresh the data
- `owner: string | null` - The owner address being queried

### TokenAccount

- `address: Address` - The token account address
- `mint: Address` - The mint address
- `owner: Address` - The owner address
- `amount: bigint` - Raw token amount
- `state: 'initialized' | 'uninitialized' | 'frozen'` - Account state
- `delegate?: Address` - Delegate authority if set
- `delegatedAmount?: bigint` - Amount delegated if applicable
- `closeAuthority?: Address` - Close authority if set
- `isNative: boolean` - Whether this is a native SOL account
- `rentExemptReserve?: bigint` - Rent-exempt reserve if native

## Example

```tsx
import { useTokenAccountsByOwner } from '@arc/solana'
import { useWalletAddress } from '@arc/solana'
import { useState } from 'react'

function TokenPortfolioViewer() {
  const { address: walletAddress } = useWalletAddress()
  const [ownerAddress, setOwnerAddress] = useState('')
  const [selectedMint, setSelectedMint] = useState('')
  const [showZeroBalances, setShowZeroBalances] = useState(false)

  const {
    tokenAccounts,
    isLoading,
    error,
    refetch,
    owner
  } = useTokenAccountsByOwner({
    owner: ownerAddress || walletAddress,
    mint: selectedMint || undefined,
    excludeZeroBalances: !showZeroBalances,
    refreshInterval: 15000 // Refresh every 15 seconds
  })

  const formatAmount = (amount: bigint, decimals: number = 9) => {
    const divisor = BigInt(10 ** decimals)
    const wholePart = amount / divisor
    const fractionalPart = amount % divisor
    return `${wholePart}.${fractionalPart.toString().padStart(decimals, '0').replace(/0+$/, '') || '0'}`
  }

  const totalAccounts = tokenAccounts?.length || 0
  const activeAccounts = tokenAccounts?.filter(acc => acc.amount > 0n).length || 0

  return (
    <div style={{ padding: '20px', maxWidth: '800px' }}>
      <h3>Token Portfolio Viewer</h3>
      
      <div style={{ marginBottom: '20px', display: 'grid', gap: '12px' }}>
        <div>
          <label>
            Owner Address (leave empty for connected wallet):
            <input
              type="text"
              value={ownerAddress}
              onChange={(e) => setOwnerAddress(e.target.value)}
              placeholder={`Current: ${walletAddress?.slice(0, 8)}...`}
              style={{ 
                width: '100%', 
                padding: '8px', 
                marginTop: '4px',
                fontSize: '14px',
                fontFamily: 'monospace'
              }}
            />
          </label>
        </div>

        <div>
          <label>
            Filter by Mint (optional):
            <input
              type="text"
              value={selectedMint}
              onChange={(e) => setSelectedMint(e.target.value)}
              placeholder="Enter mint address to filter"
              style={{ 
                width: '100%', 
                padding: '8px', 
                marginTop: '4px',
                fontSize: '14px',
                fontFamily: 'monospace'
              }}
            />
          </label>
        </div>

        <div>
          <label>
            <input
              type="checkbox"
              checked={showZeroBalances}
              onChange={(e) => setShowZeroBalances(e.target.checked)}
              style={{ marginRight: '8px' }}
            />
            Show accounts with zero balances
          </label>
        </div>

        <button
          onClick={refetch}
          disabled={isLoading}
          style={{ 
            padding: '10px 20px',
            backgroundColor: isLoading ? '#ccc' : '#2196F3',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: isLoading ? 'not-allowed' : 'pointer'
          }}
        >
          {isLoading ? 'Loading...' : 'Refresh Portfolio'}
        </button>
      </div>

      {owner && (
        <div style={{ 
          marginBottom: '16px',
          padding: '12px', 
          backgroundColor: '#f5f5f5', 
          borderRadius: '4px'
        }}>
          <p><strong>Viewing portfolio for:</strong></p>
          <code style={{ wordBreak: 'break-all' }}>{owner}</code>
        </div>
      )}

      {error && (
        <div style={{ 
          marginBottom: '16px',
          padding: '12px', 
          backgroundColor: '#ffebee', 
          border: '1px solid #f44336',
          borderRadius: '4px',
          color: '#d32f2f'
        }}>
          <strong>Error:</strong> {error.message}
        </div>
      )}

      {tokenAccounts && (
        <div style={{ marginBottom: '16px' }}>
          <div style={{ 
            display: 'flex', 
            gap: '20px', 
            padding: '12px',
            backgroundColor: '#e3f2fd',
            borderRadius: '4px'
          }}>
            <div><strong>Total Accounts:</strong> {totalAccounts}</div>
            <div><strong>With Balance:</strong> {activeAccounts}</div>
            <div><strong>Empty:</strong> {totalAccounts - activeAccounts}</div>
          </div>
        </div>
      )}

      {tokenAccounts && tokenAccounts.length > 0 ? (
        <div style={{ display: 'grid', gap: '12px' }}>
          {tokenAccounts.map((account, index) => (
            <div 
              key={account.address} 
              style={{ 
                padding: '16px', 
                border: '1px solid #ddd',
                borderRadius: '8px',
                backgroundColor: account.amount > 0n ? '#f8fffe' : '#f5f5f5'
              }}
            >
              <div style={{ display: 'grid', gap: '8px' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <h4 style={{ margin: 0 }}>Account #{index + 1}</h4>
                  <span style={{ 
                    padding: '4px 8px',
                    backgroundColor: account.state === 'initialized' ? '#4CAF50' : '#ff9800',
                    color: 'white',
                    borderRadius: '3px',
                    fontSize: '12px'
                  }}>
                    {account.state}
                  </span>
                </div>

                <div><strong>Balance:</strong> {formatAmount(account.amount)} tokens</div>
                <div><strong>Raw Amount:</strong> {account.amount.toString()}</div>
                
                <div style={{ fontSize: '14px', color: '#666' }}>
                  <div><strong>Account:</strong> <code>{account.address}</code></div>
                  <div><strong>Mint:</strong> <code>{account.mint}</code></div>
                  
                  {account.delegate && (
                    <div><strong>Delegate:</strong> <code>{account.delegate}</code></div>
                  )}
                  
                  {account.delegatedAmount && (
                    <div><strong>Delegated:</strong> {account.delegatedAmount.toString()}</div>
                  )}
                  
                  {account.closeAuthority && (
                    <div><strong>Close Authority:</strong> <code>{account.closeAuthority}</code></div>
                  )}
                  
                  {account.isNative && (
                    <div style={{ color: '#ff6d00' }}><strong>Native SOL Account</strong></div>
                  )}
                </div>
              </div>
            </div>
          ))}
        </div>
      ) : !isLoading && !error ? (
        <div style={{ 
          padding: '20px', 
          textAlign: 'center',
          backgroundColor: '#fff3e0', 
          border: '1px solid #ff9800',
          borderRadius: '4px'
        }}>
          <p>No token accounts found.</p>
          <p><small>
            {selectedMint ? 'No accounts found for the specified mint.' : 'This wallet has no token accounts.'}
          </small></p>
        </div>
      ) : null}
    </div>
  )
}
```

## Features

- **Complete Portfolio View**: Fetches all token accounts owned by a wallet
- **Flexible Filtering**: Filter by mint address or show all tokens
- **Zero Balance Control**: Option to include or exclude empty accounts
- **Real-time Updates**: Continuously monitors portfolio changes
- **Error Handling**: Comprehensive error handling with detailed messages
- **Performance Optimized**: Efficient caching and network usage

## Use Cases

- **Portfolio Dashboards**: Display complete token holdings for users
- **Wallet Interfaces**: Show all tokens in a wallet application
- **Analytics Tools**: Analyze token distribution and holdings
- **Asset Management**: Track and manage multiple token positions

## Notes

- By default, excludes accounts with zero balances for cleaner UI
- Uses jsonParsed encoding for easy data access
- Automatically refreshes every 30 seconds by default
- Returns empty array if no accounts are found
- Supports filtering by specific mint address for focused views
- The hook handles address validation and provides detailed error context