---
title: "useProgramAccount"
description: "Generic hook to parse any on-chain program account with proper typing using built-in codecs or custom parsers."
---

## Overview

The `useProgramAccount` hook is the ultimate power user feature for parsing ANY on-chain program account with proper typing. It works with both a built-in codec registry for common programs (mint, stake, vote, system) and custom codec functions for any program. This hook provides comprehensive account parsing with optional schema validation.

## Usage

```tsx
import { useProgramAccount } from '@arc/solana'

// Using built-in codec for mint accounts
function MintAccountComponent() {
  const { data: mintData, isLoading, error } = useProgramAccount({
    address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC mint
    program: 'mint'
  })

  if (isLoading) return <div>Loading mint data...</div>
  if (error) return <div>Error: {error.message}</div>
  if (!mintData) return <div>No mint data found</div>

  return (
    <div>
      <h2>Mint Information</h2>
      <p>Supply: {mintData.data.supply.toString()}</p>
      <p>Decimals: {mintData.data.decimals}</p>
      <p>Is Initialized: {mintData.data.isInitialized ? 'Yes' : 'No'}</p>
    </div>
  )
}

// Using custom codec for any program
function CustomProgramComponent() {
  const { data, isLoading, error } = useProgramAccount({
    address: 'MyProgramAccount111111111111111111111111',
    codec: async (rpc, address) => {
      const accountInfo = await rpc.getAccountInfo(address).send()
      if (!accountInfo.value) {
        throw new Error('Account not found')
      }
      
      // Custom parsing logic for your program
      return parseMyCustomProgram(accountInfo.value)
    }
  })

  // Render custom program data...
}
```

## Copy Hook Code

```typescript
'use client'

import { useQuery, useQueryClient } from '@tanstack/react-query'
import { useEffect, useCallback } from 'react'
import { useArcClient } from '../core/arc-client-provider'
import { releaseRpcConnection } from '../core/rpc-manager'
import type { Transport } from '../transports/types'
import { 
  address,
  type Address
} from '@solana/kit'
import { fetchMint } from '@solana-program/token'
import { 
  type Schema, 
  type ValidationResult,
  safeValidate,
  prepareAccountDataForValidation,
  MintAccountSchema
} from '../utils/schema-validation'
import { queryKeys } from '../utils/query-keys'

// ===== TYPES =====

export type BuiltInProgram = 'mint' | 'stake' | 'vote' | 'system'

export type CustomCodec<T> = (rpc: any, address: Address) => Promise<T>

export type ProgramAccountOptions<T> = 
  | { program: BuiltInProgram; codec?: undefined }
  | { program?: undefined; codec: CustomCodec<T> }

export interface UseProgramAccountOptions<T> {
  address?: string | Address
  enabled?: boolean
  refreshInterval?: number
  program?: BuiltInProgram
  codec?: CustomCodec<T>
  schema?: Schema<T>
  onValidationSuccess?: (data: T) => void
  onValidationError?: (error: Error) => void
  onUpdate?: (data: T) => void
}

export interface UseProgramAccountReturn<T> {
  data: T | null
  validatedData: T | null
  validation: ValidationResult<T> | null
  isLoading: boolean
  error: Error | null
  refetch: () => void
  exists: boolean
  clear: () => void
}

// ===== BUILT-IN CODEC REGISTRY =====

const BUILT_IN_CODECS: Record<BuiltInProgram, CustomCodec<any>> = {
  mint: async (rpc, addr) => {
    const mintData = await fetchMint(rpc, addr)
    return mintData.data
  },
  
  stake: async (rpc, addr) => {
    const accountInfo = await rpc.getAccountInfo(addr).send()
    if (!accountInfo.value) {
      throw new Error('Stake account not found')
    }
    
    const account = accountInfo.value
    
    if (account.owner !== 'Stake11111111111111111111111111111111111112') {
      throw new Error('Account is not owned by the Stake program')
    }
    
    // Basic parsing of stake account structure
    // Note: This is a simplified implementation pending @solana-program/stake
    return {
      account: addr,
      lamports: account.lamports,
      owner: account.owner,
      executable: account.executable,
      rentEpoch: account.rentEpoch,
      data: {
        parsed: {
          type: 'stake',
          info: {
            // Basic stake account info (simplified)
            status: 'active', // Placeholder - would need proper parsing
            lamports: account.lamports,
            note: 'Enhanced stake parsing - full implementation pending @solana-program/stake'
          }
        }
      }
    }
  },
  
  vote: async (rpc, addr) => {
    const accountInfo = await rpc.getAccountInfo(addr).send()
    if (!accountInfo.value) {
      throw new Error('Vote account not found')
    }
    
    const account = accountInfo.value
    
    if (account.owner !== 'Vote111111111111111111111111111111111111112') {
      throw new Error('Account is not owned by the Vote program')
    }
    
    // Basic parsing of vote account structure
    // Note: This is a simplified implementation pending @solana-program/vote
    return {
      account: addr,
      lamports: account.lamports,
      owner: account.owner,
      executable: account.executable,
      rentEpoch: account.rentEpoch,
      data: {
        parsed: {
          type: 'vote',
          info: {
            // Basic vote account info (simplified)
            lamports: account.lamports,
            note: 'Basic vote parsing - full implementation pending @solana-program/vote'
          }
        }
      }
    }
  },
  
  system: async (rpc, addr) => {
    const accountInfo = await rpc.getAccountInfo(addr).send()
    return accountInfo
  }
}

// ===== MAIN HOOK =====

/**
 * ðŸš€ Arc Level 3: Generic Program Account Hook
 * 
 * The ultimate power user feature - parse ANY on-chain program account with proper typing.
 * Works with both built-in codec registry and custom codec functions.
 * 
 * @example
 * ```tsx
 * // ðŸ”¥ Built-in codec registry
 * const { data: stakeAccount } = useProgramAccount<StakeAccount>(
 *   { address: 'Stake11111111111111111111111111111111111112', program: 'stake' }
 * )
 * 
 * // ðŸš€ Custom codec for any program
 * const { data: customData } = useProgramAccount<MyCustomType>({
 *   address: 'MyProgramAccount111111111111111111111111',
 *   codec: async (rpc, addr) => parseMyCustomProgram(await rpc.getAccountInfo(addr))
 * })
 * 
 * if (stakeAccount) {
 *   console.log(`Staker: ${stakeAccount.meta.authorized.staker}`)
 *   console.log(`Delegated: ${Number(stakeAccount.stake?.delegation.stake || 0n) / 1e9} SOL`)
 * }
 * ```
 */
export function useProgramAccount<T>(
  options: UseProgramAccountOptions<T>
): UseProgramAccountReturn<T> {
  const { network } = useArcClient()
  const queryClient = useQueryClient()
  
  useEffect(() => {
    return () => {
      releaseRpcConnection(network.rpcUrl)
    }
  }, [network.rpcUrl])
  
  const {
    address: accountAddress,
    enabled = true,
    refreshInterval = 60000,
    program,
    codec,
    schema,
    onValidationSuccess,
    onValidationError,
    onUpdate
  } = options

  const validateData = useCallback((rawData: T): ValidationResult<T> | null => {
    if (!schema || !rawData) return null
    
    const preparedData = prepareAccountDataForValidation(rawData)
    const result = safeValidate(preparedData, schema)
    
    if (result.success && onValidationSuccess) {
      onValidationSuccess(result.data!)
    } else if (!result.success && onValidationError) {
      onValidationError(result.error!)
    }
    
    return result
  }, [schema, onValidationSuccess, onValidationError])

  const resolvedCodec: CustomCodec<T> | null = codec || 
    (program ? (BUILT_IN_CODECS[program as BuiltInProgram] as CustomCodec<T>) : null)

  const query = useQuery({
    queryKey: [...queryKeys.programAccount(program || 'custom', accountAddress || undefined), network.rpcUrl, schema ? 'schema' : 'raw'],
    queryFn: async (): Promise<{ data: T | null; validation: ValidationResult<T> | null }> => {
      if (!accountAddress) {
        throw new Error('Account address is required')
      }

      if (!resolvedCodec) {
        throw new Error('Either program or codec must be provided')
      }
      
      const transport = (useArcClient() as any).config.transport as Transport
      const rpcShim = {
        getAccountInfo: (addr: any, opts?: any) => ({
          send: () => transport.request({ method: 'getAccountInfo', params: [addr, opts] })
        })
      } as any
      
      try {
        const parsedData = await resolvedCodec(rpcShim, address(accountAddress))
        
        const validation = validateData(parsedData)
        
        if (onUpdate) {
          if (validation?.success) {
            onUpdate(validation.data!)
          } else {
            onUpdate(parsedData)
          }
        }
        
        return { data: parsedData, validation }
      } catch (error) {
        console.error('âŒ [useProgramAccount] Failed to fetch/parse account data:', error)
        throw error
      }
    },
    enabled: enabled && !!accountAddress && !!resolvedCodec,
    refetchInterval: refreshInterval,
    refetchOnWindowFocus: false,
    staleTime: 30_000,
    gcTime: 5 * 60_000,
    retry: 1,
    notifyOnChangeProps: ['data', 'error'],
  })

  const clear = useCallback(() => {
    const key = [...queryKeys.programAccount(program || 'custom', accountAddress || undefined), network.rpcUrl, schema ? 'schema' : 'raw']
    queryClient.cancelQueries({ queryKey: key, exact: true }).finally(() => {
      queryClient.removeQueries({ queryKey: key, exact: true })
    })
  }, [accountAddress, network.rpcUrl, program, schema, queryClient])

  return {
    data: query.data?.data || null,
    validatedData: query.data?.validation?.success ? query.data.validation.data! : null,
    validation: query.data?.validation || null,
    isLoading: query.isLoading,
    error: query.error,
    refetch: query.refetch,
    exists: !!query.data?.data,
    clear,
  }
}

// ===== UTILITY TYPE EXPORTS =====

export interface MintAccount {
  mintAuthority: { __option: 'Some'; value: Address } | { __option: 'None' }
  supply: bigint
  decimals: number
  isInitialized: boolean
  freezeAuthority: { __option: 'Some'; value: Address } | { __option: 'None' }
}

export interface StakeAccount {
  account: Address
  lamports: bigint
  owner: string
  executable: boolean
  rentEpoch: number
  data: {
    parsed: {
      type: 'stake'
      info: {
        status: string
        lamports: bigint
        note: string
        // Extended fields will be added when @solana-program/stake is available:
        // meta?: {
        //   rentExemptReserve: bigint
        //   authorized: {
        //     staker: Address
        //     withdrawer: Address
        //   }
        //   lockup: {
        //     unixTimestamp: bigint
        //     epoch: bigint
        //     custodian: Address
        //   }
        // }
        // stake?: {
        //   delegation: {
        //     voterPubkey: Address
        //     stake: bigint
        //     activationEpoch: bigint
        //     deactivationEpoch: bigint
        //     warmupCooldownRate: number
        //   }
        //   creditsObserved: bigint
        // }
      }
    }
  }
}

export interface SystemAccount {
  lamports: bigint
  data: Uint8Array
  owner: Address
  executable: boolean
  rentEpoch: bigint
}
```

## Parameters

The `useProgramAccount` hook accepts an options object with the following properties:

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `address` | `string \| Address` | `undefined` | The account address to fetch and parse |
| `enabled` | `boolean` | `true` | Whether the query should run automatically |
| `refreshInterval` | `number` | `60000` | Interval in milliseconds to automatically refetch data |
| `program` | `BuiltInProgram` | `undefined` | Built-in program type ('mint', 'stake', 'vote', 'system') |
| `codec` | `CustomCodec<T>` | `undefined` | Custom parsing function for the account data |
| `schema` | `Schema<T>` | `undefined` | Optional schema for data validation |
| `onValidationSuccess` | `(data: T) => void` | `undefined` | Callback fired when validation succeeds |
| `onValidationError` | `(error: Error) => void` | `undefined` | Callback fired when validation fails |
| `onUpdate` | `(data: T) => void` | `undefined` | Callback fired when data updates |

### Built-in Programs

| Program | Description |
|---------|-------------|
| `'mint'` | SPL Token mint accounts |
| `'stake'` | Solana stake accounts (basic parsing) |
| `'vote'` | Solana vote accounts (basic parsing) |
| `'system'` | System program accounts |

### Custom Codec Function

```typescript
type CustomCodec<T> = (rpc: any, address: Address) => Promise<T>
```

The codec function receives an RPC client and the account address, and should return the parsed account data.

## Return Value

The hook returns an object with the following properties:

| Property | Type | Description |
|----------|------|-------------|
| `data` | `T \| null` | Parsed account data or null if not loaded |
| `validatedData` | `T \| null` | Schema-validated data (only if schema provided and validation passes) |
| `validation` | `ValidationResult<T> \| null` | Validation result object if schema is provided |
| `isLoading` | `boolean` | Whether the request is currently loading |
| `error` | `Error \| null` | Error object if the request failed |
| `refetch` | `() => void` | Function to manually refetch the account |
| `exists` | `boolean` | Whether the account exists |
| `clear` | `() => void` | Function to clear the cached data |

## Example

```tsx
import { useProgramAccount, type MintAccount } from '@arc/solana'

function TokenMintAnalyzer() {
  const [mintAddress, setMintAddress] = useState('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v') // USDC

  const { 
    data: mintData, 
    validatedData,
    validation,
    isLoading, 
    error, 
    exists,
    refetch 
  } = useProgramAccount<MintAccount>({
    address: mintAddress,
    program: 'mint',
    refreshInterval: 30000,
    onValidationSuccess: (data) => {
      console.log('Mint data validated successfully:', data)
    },
    onValidationError: (error) => {
      console.error('Mint validation failed:', error)
    }
  })

  const handleMintChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setMintAddress(event.target.value)
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center p-8">
        <div className="text-lg">Loading mint account...</div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <h3 className="text-red-800 font-semibold">Error loading mint</h3>
        <p className="text-red-600">{error.message}</p>
        <button 
          onClick={() => refetch()}
          className="mt-2 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
        >
          Retry
        </button>
      </div>
    )
  }

  if (!exists || !mintData) {
    return (
      <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
        <h3 className="text-yellow-800 font-semibold">Mint not found</h3>
        <p className="text-yellow-600">The specified mint account does not exist</p>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h2 className="text-2xl font-bold">Token Mint Analyzer</h2>
        <button 
          onClick={() => refetch()}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
        >
          Refresh
        </button>
      </div>

      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Mint Address
          </label>
          <input
            type="text"
            value={mintAddress}
            onChange={handleMintChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Enter mint address..."
          />
        </div>

        <div className="bg-white border border-gray-200 rounded-lg p-6">
          <h3 className="text-lg font-semibold mb-4">Mint Information</h3>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="text-sm font-medium text-gray-600">Supply</label>
              <p className="text-lg font-mono">
                {(Number(mintData.data.supply) / Math.pow(10, mintData.data.decimals)).toLocaleString()}
              </p>
            </div>
            
            <div>
              <label className="text-sm font-medium text-gray-600">Decimals</label>
              <p className="text-lg font-mono">{mintData.data.decimals}</p>
            </div>
            
            <div>
              <label className="text-sm font-medium text-gray-600">Initialized</label>
              <p className={`text-lg font-semibold ${mintData.data.isInitialized ? 'text-green-600' : 'text-red-600'}`}>
                {mintData.data.isInitialized ? 'Yes' : 'No'}
              </p>
            </div>
            
            <div>
              <label className="text-sm font-medium text-gray-600">Mint Authority</label>
              <p className="text-sm font-mono break-all">
                {mintData.data.mintAuthority.__option === 'Some' 
                  ? mintData.data.mintAuthority.value 
                  : 'None (Fixed Supply)'}
              </p>
            </div>
            
            <div className="md:col-span-2">
              <label className="text-sm font-medium text-gray-600">Freeze Authority</label>
              <p className="text-sm font-mono break-all">
                {mintData.data.freezeAuthority.__option === 'Some' 
                  ? mintData.data.freezeAuthority.value 
                  : 'None'}
              </p>
            </div>
          </div>

          {validation && (
            <div className="mt-4 p-3 rounded-lg bg-gray-50">
              <h4 className="text-sm font-medium text-gray-700">Validation Status</h4>
              <p className={`text-sm ${validation.success ? 'text-green-600' : 'text-red-600'}`}>
                {validation.success ? 'Data validated successfully' : `Validation failed: ${validation.error?.message}`}
              </p>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}

// Example with custom codec
function CustomProgramAccount() {
  const { data, isLoading, error } = useProgramAccount({
    address: 'YourCustomProgramAccount111111111111111111',
    codec: async (rpc, address) => {
      const accountInfo = await rpc.getAccountInfo(address).send()
      if (!accountInfo.value) {
        throw new Error('Account not found')
      }
      
      // Parse your custom program data
      const data = accountInfo.value.data
      // Custom parsing logic here...
      
      return {
        customField1: 'parsed value',
        customField2: 123,
        // ... other parsed fields
      }
    },
    refreshInterval: 60000
  })

  // Render your custom data...
}
```

This example demonstrates how to use `useProgramAccount` with both built-in codecs (for mint accounts) and how you could implement custom codecs for any program account type.