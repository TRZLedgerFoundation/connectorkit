---
title: useTransferToken
description: Hook for transferring SPL tokens with automatic account creation
---

# useTransferToken

The `useTransferToken` hook provides an easy way to transfer SPL tokens between addresses. It includes automatic recipient token account creation and built-in form input helpers.

## Usage

### Direct Import
```tsx
import { useTransferToken } from '@arc/solana'

function MyComponent() {
  const { 
    transferToken, 
    isLoading, 
    mintInput,
    toInput,
    amountInput,
    setMintInput,
    setToInput,
    setAmountInput,
    handleSubmit 
  } = useTransferToken()
  
  return (
    <form onSubmit={handleSubmit}>
      <input 
        value={mintInput}
        onChange={(e) => setMintInput(e.target.value)}
        placeholder="Token mint address"
      />
      <input 
        value={toInput}
        onChange={(e) => setToInput(e.target.value)}
        placeholder="Recipient address"
      />
      <input 
        value={amountInput}
        onChange={(e) => setAmountInput(e.target.value)}
        placeholder="Amount"
      />
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Sending...' : 'Transfer Token'}
      </button>
    </form>
  )
}
```

### Copy Hook Code
If you prefer to copy the hook directly:

```tsx
'use client'

import { useMutation, useQueryClient } from '@tanstack/react-query'
import { useCallback, useEffect, useRef, useState } from 'react'
import { useArcClient } from '../core/arc-client-provider'
import { getSharedRpc, getSharedWebSocket, releaseRpcConnection } from '../core/rpc-manager'
import type { Transport } from '../transports/types'
import { 
  sendAndConfirmTransactionFactory,
  createTransactionMessage,
  pipe,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  signTransactionMessageWithSigners,
  getSignatureFromTransaction,
  address,
  type Address,
  type TransactionSigner,
  type Instruction
} from '@solana/kit'
import { 
  TOKEN_PROGRAM_ADDRESS, 
  findAssociatedTokenPda,
  getTransferInstruction,
  getCreateAssociatedTokenInstruction
} from '@solana-program/token'
import { createInvalidator } from '../utils/invalidate'

export interface TransferTokenOptions {
  mint: string | Address  // mint address
  to: string | Address    // recipient wallet address
  amount: bigint  // amount in token's smallest unit (considering decimals)
  from?: string | Address  // auto: Uses connected wallet if not provided
  createAccountIfNeeded?: boolean  // auto-create recipient's ATA if it doesn't exist
}

export interface TransferTokenResult {
  signature: string
  mint: Address
  amount: bigint
  from: Address
  to: Address
  fromTokenAccount: Address
  toTokenAccount: Address
  createdAccount?: boolean 
  blockTime?: number
  slot?: number
}

export interface UseTransferTokenReturn {
  transferToken: (options: TransferTokenOptions) => Promise<TransferTokenResult>
  isLoading: boolean
  error: Error | null
  data: TransferTokenResult | null
  reset: () => void
  
  // UI INTERACTION HELPERS
  /** Input state for token mint address */
  mintInput: string
  /** Input state for recipient address */
  toInput: string
  /** Input state for amount (in token units) */
  amountInput: string
  /** Set mint input */
  setMintInput: (value: string) => void
  /** Set recipient address input */
  setToInput: (value: string) => void
  /** Set amount input */
  setAmountInput: (value: string) => void
  /** onChange handler for mint input */
  handleMintInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void
  /** onChange handler for recipient address input */
  handleToInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void
  /** onChange handler for amount input */
  handleAmountInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void
  /** Form submission handler that transfers tokens using current input values */
  handleSubmit: (event?: { preventDefault?: () => void }) => Promise<TransferTokenResult | undefined>
  /** Shortcut to transfer tokens using current input values */
  transferFromInputs: () => Promise<TransferTokenResult | undefined>
}

export function useTransferToken(
  initialMintInput: string = '',
  initialToInput: string = '',
  initialAmountInput: string = ''
): UseTransferTokenReturn {
  const { wallet, network, config } = useArcClient()
  const queryClient = useQueryClient()
  
  const [mintInput, setMintInput] = useState(initialMintInput)
  const [toInput, setToInput] = useState(initialToInput)
  const [amountInput, setAmountInput] = useState(initialAmountInput)
  
  const stableOptionsRef = useRef({
    network: network.rpcUrl,
    commitment: config.commitment || 'confirmed',
  })
  
  useEffect(() => {
    stableOptionsRef.current = {
      network: network.rpcUrl,
      commitment: config.commitment || 'confirmed',
    }
  }, [network.rpcUrl, config.commitment])
  
  useEffect(() => {
    return () => {
      releaseRpcConnection(network.rpcUrl)
    }
  }, [network.rpcUrl])
  
  const mutation = useMutation({
    mutationFn: async (options: TransferTokenOptions): Promise<TransferTokenResult> => {
      const { 
        mint, 
        to, 
        amount, 
        from: optionsFrom,
        createAccountIfNeeded = true 
      } = options
      
      const fromAddress = optionsFrom || wallet.address
      
      if (!fromAddress) {
        throw new Error('No sender address provided and no wallet connected')
      }
      
      if (!wallet.signer) {
        throw new Error('Wallet not connected or no signer available')
      }
      
      
      
      const rpc = getSharedRpc(network.rpcUrl)
      const transport = (useArcClient() as any).config.transport as Transport
      
      const [fromTokenAccount] = await findAssociatedTokenPda({
        mint: address(mint),
        owner: address(fromAddress),
        tokenProgram: TOKEN_PROGRAM_ADDRESS,
      })
      
      const [toTokenAccount] = await findAssociatedTokenPda({
        mint: address(mint),
        owner: address(to),
        tokenProgram: TOKEN_PROGRAM_ADDRESS,
      })
      
      
      
      const toAccountInfo: any = await transport.request(
        { method: 'getAccountInfo', params: [toTokenAccount] }
      )
      const needsToCreateAccount = !toAccountInfo.value && createAccountIfNeeded
      
      if (!toAccountInfo.value && !createAccountIfNeeded) {
        throw new Error('Recipient token account does not exist and createAccountIfNeeded is false')
      }
      
      
      
      const { value: latestBlockhash }: any = await transport.request(
        { method: 'getLatestBlockhash', params: [] }
      )
      
      
      const instructions: Instruction[] = []
      
      if (needsToCreateAccount) {
        const createAccountInstruction = getCreateAssociatedTokenInstruction({
          payer: wallet.signer as TransactionSigner,
          ata: toTokenAccount,
          owner: address(to),
          mint: address(mint),
        })
        instructions.push(createAccountInstruction)
      
      }
      
      const transferInstruction = getTransferInstruction({
        source: fromTokenAccount,
        destination: toTokenAccount,
        authority: address(fromAddress),
        amount,
      })
      instructions.push(transferInstruction)
      
      
      const rpcSubscriptions = getSharedWebSocket(network.rpcUrl)
      const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc: rpc as any, rpcSubscriptions: rpcSubscriptions as any })
      
      const transactionMessage = pipe(
        createTransactionMessage({ version: 0 }),
        tx => setTransactionMessageFeePayerSigner(wallet.signer as TransactionSigner, tx),
        tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
        tx => appendTransactionMessageInstructions(instructions, tx),
      )
      
      
      
      const signedTransaction = await signTransactionMessageWithSigners(transactionMessage)
      const signature = getSignatureFromTransaction(signedTransaction)
      
      
      
      await sendAndConfirmTransaction(signedTransaction, { 
        commitment: 'confirmed',
        skipPreflight: false
      })
      
      
      
      const result: TransferTokenResult = {
        signature,
        mint: address(mint),
        amount,
        from: address(fromAddress),
        to: address(to),
        fromTokenAccount,
        toTokenAccount,
        createdAccount: needsToCreateAccount
      }
      
      return result
    },
    onSuccess: async (result) => {
      // Invalidate cache for both sender and recipient token accounts
      const invalidator = createInvalidator(queryClient)
      await invalidator.invalidateAfterTokenTransfer(
        result.from.toString(),
        result.to.toString(),
        result.mint.toString(),
        { refetch: true }
      )
    },
    onError: () => {}
  })

  const handleMintInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setMintInput(event.target.value)
  }, [])
  
  const handleToInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setToInput(event.target.value)
  }, [])
  
  const handleAmountInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setAmountInput(event.target.value)
  }, [])
  
  const transferFromInputs = useCallback(async () => {
    if (!mintInput || !toInput || !amountInput) {
      throw new Error('Mint address, recipient address, and amount are all required')
    }
    
    try {
      // Parse amount as BigInt (assume token has standard decimals handling)
      const amountBigInt = BigInt(amountInput)
      
      return await mutation.mutateAsync({
        mint: mintInput,
        to: toInput,
        amount: amountBigInt,
        createAccountIfNeeded: true, // Default to auto-create
      })
    } catch (error) { throw error }
  }, [mintInput, toInput, amountInput, mutation.mutateAsync])
  
  const handleSubmit = useCallback(async (event?: { preventDefault?: () => void }) => {
    event?.preventDefault?.()
    return mintInput && toInput && amountInput ? transferFromInputs() : undefined
  }, [mintInput, toInput, amountInput, transferFromInputs])

  return {
    transferToken: mutation.mutateAsync,
    isLoading: mutation.isPending,
    error: mutation.error,
    data: mutation.data || null,
    reset: mutation.reset,
    mintInput,
    toInput,
    amountInput,
    setMintInput,
    setToInput,
    setAmountInput,
    handleMintInputChange,
    handleToInputChange,
    handleAmountInputChange,
    handleSubmit,
    transferFromInputs,
  }
}
```

## Parameters

- `initialMintInput?: string` - Initial value for mint address input (default: '')
- `initialToInput?: string` - Initial value for recipient address input (default: '')
- `initialAmountInput?: string` - Initial value for amount input (default: '')

## Return Value

### Core Functions
- `transferToken: (options: TransferTokenOptions) => Promise<TransferTokenResult>` - Transfer token function
- `isLoading: boolean` - Whether a transfer is in progress
- `error: Error | null` - Any error that occurred
- `data: TransferTokenResult | null` - Last successful transfer result
- `reset: () => void` - Reset the mutation state

### Form Helpers
- `mintInput: string` - Current mint address input value
- `toInput: string` - Current recipient address input value
- `amountInput: string` - Current amount input value
- `setMintInput: (value: string) => void` - Set mint input
- `setToInput: (value: string) => void` - Set recipient input
- `setAmountInput: (value: string) => void` - Set amount input
- `handleMintInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void` - Input change handler
- `handleToInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void` - Input change handler
- `handleAmountInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void` - Input change handler
- `handleSubmit: (event?: { preventDefault?: () => void }) => Promise<TransferTokenResult | undefined>` - Form submit handler
- `transferFromInputs: () => Promise<TransferTokenResult | undefined>` - Transfer using current input values

## TransferTokenOptions

- `mint: string | Address` - SPL token mint address
- `to: string | Address` - Recipient wallet address
- `amount: bigint` - Amount in token's smallest unit (considering decimals)
- `from?: string | Address` - Sender address (uses connected wallet if not provided)
- `createAccountIfNeeded?: boolean` - Auto-create recipient's ATA if it doesn't exist (default: true)

## TransferTokenResult

- `signature: string` - Transaction signature
- `mint: Address` - Token mint address
- `amount: bigint` - Amount transferred
- `from: Address` - Sender address
- `to: Address` - Recipient address
- `fromTokenAccount: Address` - Sender's token account
- `toTokenAccount: Address` - Recipient's token account
- `createdAccount?: boolean` - Whether recipient account was created
- `blockTime?: number` - Block timestamp
- `slot?: number` - Slot number

## Example

### Basic Usage
```tsx
import { useTransferToken } from '@arc/solana'

function TokenTransfer() {
  const { transferToken, isLoading, error, data } = useTransferToken()

  const handleTransfer = async () => {
    try {
      const result = await transferToken({
        mint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
        to: 'recipient-address-here',
        amount: 1000000n, // 1 USDC (6 decimals)
        createAccountIfNeeded: true
      })
      console.log('Transfer successful:', result.signature)
    } catch (err) {
      console.error('Transfer failed:', err)
    }
  }

  return (
    <div>
      <button onClick={handleTransfer} disabled={isLoading}>
        {isLoading ? 'Sending...' : 'Send 1 USDC'}
      </button>
      {error && <p>Error: {error.message}</p>}
      {data && <p>Success! Signature: {data.signature}</p>}
    </div>
  )
}
```

### With Form Inputs
```tsx
import { useTransferToken } from '@arc/solana'

function TokenTransferForm() {
  const { 
    mintInput,
    toInput,
    amountInput,
    setMintInput,
    setToInput,
    setAmountInput,
    handleSubmit,
    isLoading,
    error,
    data
  } = useTransferToken()

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Token Mint:</label>
        <input 
          type="text"
          value={mintInput}
          onChange={(e) => setMintInput(e.target.value)}
          placeholder="Enter token mint address"
          required
        />
      </div>
      
      <div>
        <label>Recipient:</label>
        <input 
          type="text"
          value={toInput}
          onChange={(e) => setToInput(e.target.value)}
          placeholder="Enter recipient address"
          required
        />
      </div>
      
      <div>
        <label>Amount:</label>
        <input 
          type="number"
          value={amountInput}
          onChange={(e) => setAmountInput(e.target.value)}
          placeholder="Enter amount (raw units)"
          min="0"
          required
        />
      </div>
      
      <button type="submit" disabled={isLoading || !mintInput || !toInput || !amountInput}>
        {isLoading ? 'Sending...' : 'Transfer Token'}
      </button>
      
      {error && (
        <div style={{ color: 'red' }}>
          Error: {error.message}
        </div>
      )}
      
      {data && (
        <div style={{ color: 'green' }}>
          Success! Transferred {data.amount.toString()} tokens
          <br />
          Signature: {data.signature}
          {data.createdAccount && <br />}
          {data.createdAccount && 'Created new token account for recipient'}
        </div>
      )}
    </form>
  )
}
```

### USDC Transfer Helper
```tsx
import { useTransferToken } from '@arc/solana'

const USDC_MINT = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'
const USDC_DECIMALS = 6

function USDCTransfer() {
  const { transferToken, isLoading } = useTransferToken()
  const [recipient, setRecipient] = useState('')
  const [usdcAmount, setUsdcAmount] = useState('')

  const handleTransfer = async () => {
    if (!recipient || !usdcAmount) return

    try {
      const amount = BigInt(Math.floor(parseFloat(usdcAmount) * Math.pow(10, USDC_DECIMALS)))
      
      await transferToken({
        mint: USDC_MINT,
        to: recipient,
        amount,
        createAccountIfNeeded: true
      })
      
      alert('USDC transfer successful!')
      setRecipient('')
      setUsdcAmount('')
    } catch (error) {
      alert(`Transfer failed: ${error.message}`)
    }
  }

  return (
    <div>
      <h3>Send USDC</h3>
      <input 
        value={recipient}
        onChange={(e) => setRecipient(e.target.value)}
        placeholder="Recipient address"
      />
      <input 
        value={usdcAmount}
        onChange={(e) => setUsdcAmount(e.target.value)}
        placeholder="Amount in USDC"
        type="number"
        step="0.000001"
      />
      <button onClick={handleTransfer} disabled={isLoading || !recipient || !usdcAmount}>
        {isLoading ? 'Sending...' : 'Send USDC'}
      </button>
    </div>
  )
}
```

### With Account Creation Handling
```tsx
import { useTransferToken } from '@arc/solana'

function SmartTokenTransfer() {
  const { transferToken, isLoading } = useTransferToken()

  const handleTransfer = async (mint: string, to: string, amount: bigint) => {
    try {
      const result = await transferToken({
        mint,
        to,
        amount,
        createAccountIfNeeded: true // This is the default
      })

      if (result.createdAccount) {
        console.log('Created new token account for recipient')
      }

      return result
    } catch (error) {
      // Handle specific error cases
      if (error.message.includes('does not exist')) {
        console.log('Recipient needs a token account, but auto-creation is disabled')
      }
      throw error
    }
  }

  return (
    <div>
      {/* Your UI */}
    </div>
  )
}
```