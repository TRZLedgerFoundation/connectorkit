---
title: "useMultipleAccounts"
description: "Fetch multiple Solana accounts in a single RPC call for optimal performance."
---

## Overview

The `useMultipleAccounts` hook allows you to fetch multiple Solana accounts in a single RPC call, providing optimal performance when you need account data for multiple addresses. This hook is perfect for scenarios where you need to load account information for multiple addresses efficiently.

## Usage

```tsx
import { useMultipleAccounts } from '@connectorkit/solana'

function MultipleAccountsComponent() {
  const { accounts, isLoading, error } = useMultipleAccounts({
    addresses: [
      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC mint
      'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', // USDT mint  
      '7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj'  // stSOL mint
    ],
    commitment: 'confirmed',
    encoding: 'base64'
  })

  if (isLoading) return <div>Loading accounts...</div>
  if (error) return <div>Error: {error.message}</div>
  if (!accounts) return <div>No accounts found</div>

  return (
    <div>
      <h2>Account Information</h2>
      {accounts.map((account, index) => (
        <div key={index}>
          <p>Address: {account.address}</p>
          <p>Exists: {account.exists ? 'Yes' : 'No'}</p>
          {account.exists && (
            <>
              <p>Balance: {Number(account.lamports) / 1e9} SOL</p>
              <p>Owner: {account.owner}</p>
              <p>Executable: {account.executable ? 'Yes' : 'No'}</p>
            </>
          )}
        </div>
      ))}
    </div>
  )
}
```

## Copy Hook Code

```typescript
'use client'

import { useQuery, useQueryClient } from '@tanstack/react-query'
import { useCallback } from 'react'
import { useArcClient } from '../core/arc-client-provider'
import type { Transport } from '../transports/types'
import { 
  ArcError,
  ArcErrorCode,
  createNetworkError,
  type ArcErrorContext
} from '../core/error-handler'
import { address, type Address } from '@solana/kit'

async function fetchMultipleAccountsCore(
  addresses: Address[],
  transport: Transport,
  config: {
    commitment: 'processed' | 'confirmed' | 'finalized'
    encoding: 'base58' | 'base64' | 'base64+zstd' | 'jsonParsed'
    dataSlice?: { offset: number; length: number }
  }
): Promise<AccountInfo[]> {
  // transport-based implementation
  const validAddresses = addresses.map(addr => {
    try {
      return address(addr)
    } catch (error) {
      throw new Error(`Invalid address format: ${addr}`)
    }
  })

  const rpcConfig: any = {
    commitment: config.commitment,
    encoding: config.encoding,
  }
  
  if (config.dataSlice) {
    rpcConfig.dataSlice = config.dataSlice
  }

  const response: any = await transport.request(
    { method: 'getMultipleAccounts', params: [validAddresses, rpcConfig] }
  )
  
  const accounts: AccountInfo[] = response.value.map((account: any, index: number) => {
    const addr = validAddresses[index]
    
    if (!account) {
      return {
        address: addr,
        data: null,
        exists: false,
        executable: false,
        lamports: 0n,
        owner: null,
        rentEpoch: 0n,
      }
    }

    return {
      address: addr,
      data: account.data ? (
        config.encoding === 'base64' ? 
          new Uint8Array(Buffer.from(account.data[0], 'base64')) : 
          account.data instanceof Uint8Array ? account.data : null
      ) : null,
      exists: true,
      executable: account.executable,
      lamports: account.lamports,
      owner: account.owner ? address(account.owner) : null,
      rentEpoch: account.rentEpoch,
    }
  })

  
  return accounts
}

export interface UseMultipleAccountsOptions {
  addresses: Address[]
  refreshInterval?: number
  enabled?: boolean
  commitment?: 'processed' | 'confirmed' | 'finalized'
  encoding?: 'base58' | 'base64' | 'base64+zstd' | 'jsonParsed'
  dataSlice?: {
    offset: number
    length: number
  }
}

export interface AccountInfo {
  address: Address
  data: Uint8Array | null
  exists: boolean
  executable: boolean
  lamports: bigint
  owner: Address | null
  rentEpoch: bigint
}

export interface UseMultipleAccountsReturn {
  accounts: AccountInfo[] | null
  isLoading: boolean
  error: ArcError | null
  refetch: () => void
  clear: () => void
}

/**
 * Fetch multiple accounts in a single RPC call for optimal performance.
 */
export function useMultipleAccounts(
  options: UseMultipleAccountsOptions
): UseMultipleAccountsReturn {
  const { network, config } = useArcClient()
  const queryClient = useQueryClient()
  
  const {
    addresses,
    refreshInterval,
    enabled = true,
    commitment = 'confirmed',
    encoding = 'base64',
    dataSlice,
  } = options

  const query = useQuery<AccountInfo[], ArcError>({
    queryKey: ['multipleAccounts', network.rpcUrl, addresses, commitment, encoding, dataSlice],
    queryFn: async () => {
      const context: ArcErrorContext = {
        operation: 'getMultipleAccounts',
        timestamp: Date.now(),
        rpcUrl: network.rpcUrl
      }

      if (!addresses.length) {
        return []
      }

      try {
        return await fetchMultipleAccountsCore(addresses, (config as any).transport, {
          commitment,
          encoding,
          dataSlice,
        })
      } catch (error) {
        if (error instanceof Error && error.message.includes('Invalid address format')) {
          throw new ArcError(
            error.message,
            ArcErrorCode.INVALID_ADDRESS,
            context,
            error
          )
        }
        
        const errorMessage = error instanceof Error ? error.message : String(error)
        throw createNetworkError(
          `Failed to fetch multiple accounts: ${errorMessage}`,
          context,
          error as Error
        )
      }
    },
    enabled: enabled && addresses.length > 0,
    refetchInterval: refreshInterval,
    refetchOnWindowFocus: false,
    staleTime: 15_000,
    gcTime: 5 * 60_000,
    retry: 1,
    notifyOnChangeProps: ['data', 'error', 'isLoading'],
  })

  const clear = useCallback(() => {
    const key = ['multipleAccounts', network.rpcUrl, addresses, commitment, encoding, dataSlice] as const
    queryClient.cancelQueries({ queryKey: key, exact: true }).finally(() => {
      queryClient.removeQueries({ queryKey: key, exact: true })
    })
  }, [addresses, commitment, dataSlice, encoding, network.rpcUrl, queryClient])

  return {
    accounts: query.data ?? null,
    isLoading: query.isLoading,
    error: query.error ?? null,
    refetch: query.refetch,
    clear,
  }
}
```

## Parameters

The `useMultipleAccounts` hook accepts an options object with the following properties:

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `addresses` | `Address[]` | **Required** | Array of account addresses to fetch |
| `refreshInterval` | `number` | `undefined` | Interval in milliseconds to automatically refetch data |
| `enabled` | `boolean` | `true` | Whether the query should run automatically |
| `commitment` | `'processed' \| 'confirmed' \| 'finalized'` | `'confirmed'` | Commitment level for the RPC call |
| `encoding` | `'base58' \| 'base64' \| 'base64+zstd' \| 'jsonParsed'` | `'base64'` | Encoding format for account data |
| `dataSlice` | `{ offset: number; length: number }` | `undefined` | Optional data slice to limit returned data |

## Return Value

The hook returns an object with the following properties:

| Property | Type | Description |
|----------|------|-------------|
| `accounts` | `AccountInfo[] \| null` | Array of account information objects or null if not loaded |
| `isLoading` | `boolean` | Whether the request is currently loading |
| `error` | `ArcError \| null` | Error object if the request failed |
| `refetch` | `() => void` | Function to manually refetch the accounts |
| `clear` | `() => void` | Function to clear the cached data |

### AccountInfo Type

```typescript
interface AccountInfo {
  address: Address
  data: Uint8Array | null
  exists: boolean
  executable: boolean
  lamports: bigint
  owner: Address | null
  rentEpoch: bigint
}
```

## Example

```tsx
import { useMultipleAccounts } from '@connectorkit/solana'

function TokenMintList() {
  const tokenMints = [
    'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
    'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', // USDT
    'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So',  // mSOL
    '7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj'  // stSOL
  ]

  const { accounts, isLoading, error, refetch } = useMultipleAccounts({
    addresses: tokenMints,
    commitment: 'confirmed',
    encoding: 'base64',
    refreshInterval: 30000 // Refresh every 30 seconds
  })

  if (isLoading) {
    return (
      <div className="flex items-center justify-center p-8">
        <div className="text-lg">Loading token mint accounts...</div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <h3 className="text-red-800 font-semibold">Error loading accounts</h3>
        <p className="text-red-600">{error.message}</p>
        <button 
          onClick={() => refetch()}
          className="mt-2 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
        >
          Retry
        </button>
      </div>
    )
  }

  if (!accounts || accounts.length === 0) {
    return <div>No accounts found</div>
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h2 className="text-2xl font-bold">Token Mint Accounts</h2>
        <button 
          onClick={() => refetch()}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
        >
          Refresh
        </button>
      </div>
      
      <div className="grid gap-4">
        {accounts.map((account, index) => (
          <div 
            key={index}
            className="border border-gray-200 rounded-lg p-4"
          >
            <div className="font-mono text-sm text-gray-600 mb-2">
              {account.address}
            </div>
            
            {account.exists ? (
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-gray-700">Status:</span>
                  <span className="text-green-600 font-semibold">Active</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-700">Balance:</span>
                  <span className="font-mono">
                    {(Number(account.lamports) / 1e9).toFixed(9)} SOL
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-700">Owner:</span>
                  <span className="font-mono text-xs">
                    {account.owner}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-700">Executable:</span>
                  <span className={account.executable ? 'text-orange-600' : 'text-gray-500'}>
                    {account.executable ? 'Yes' : 'No'}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-700">Rent Epoch:</span>
                  <span className="font-mono">{account.rentEpoch.toString()}</span>
                </div>
              </div>
            ) : (
              <div className="text-red-600 font-semibold">
                Account does not exist
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  )
}
```

This example demonstrates how to use `useMultipleAccounts` to efficiently fetch and display information for multiple token mint accounts, including proper loading states, error handling, and data presentation.