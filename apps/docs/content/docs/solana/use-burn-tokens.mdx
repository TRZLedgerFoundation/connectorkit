---
title: useBurnTokens
description: Hook to burn tokens with form input management and account handling
---

# useBurnTokens

The `useBurnTokens` hook provides functionality to burn SPL tokens from a token account, with built-in form input management and automatic associated token account resolution.

## Usage

### Direct Import
```tsx
import { useBurnTokens } from '@arc/solana'

function BurnTokensForm() {
  const {
    burnTokens,
    isLoading,
    error,
    data,
    mintInput,
    amountInput,
    decimalsInput,
    setMintInput,
    setAmountInput,
    setDecimalsInput,
    handleSubmit
  } = useBurnTokens()

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={mintInput}
        onChange={(e) => setMintInput(e.target.value)}
        placeholder="Mint address"
      />
      <input
        value={amountInput}
        onChange={(e) => setAmountInput(e.target.value)}
        placeholder="Amount (raw units)"
      />
      <input
        value={decimalsInput}
        onChange={(e) => setDecimalsInput(e.target.value)}
        placeholder="Decimals"
      />
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Burning...' : 'Burn Tokens'}
      </button>
      {error && <div>Error: {error.message}</div>}
      {data && <div>Burned! Signature: {data.signature}</div>}
    </form>
  )
}
```

### Copy Hook Code
```tsx
'use client'

import { useMutation } from '@tanstack/react-query'
import { useCallback, useEffect, useRef, useState } from 'react'
import { useArcClient } from '../core/arc-client-provider'
import { getSharedRpc, getSharedWebSocket, releaseRpcConnection } from '../core/rpc-manager'
import type { Transport } from '../transports/types'
import { 
  sendAndConfirmTransactionFactory,
  createTransactionMessage,
  pipe,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  signTransactionMessageWithSigners,
  getSignatureFromTransaction,
  address,
  type Address,
  type TransactionSigner,
  type Instruction
} from '@solana/kit'
import { 
  TOKEN_PROGRAM_ADDRESS, 
  findAssociatedTokenPda,
  getBurnCheckedInstruction
} from '@solana-program/token'

export interface BurnTokensOptions {
  mint: string | Address
  from?: string | Address
  tokenAccount?: string | Address
  amount: bigint
  decimals: number
}

export interface BurnTokensResult {
  signature: string
  mint: Address
  amount: bigint
  decimals: number
  from: Address
  fromTokenAccount: Address
  blockTime?: number
  slot?: number
}

export interface UseBurnTokensReturn {
  burnTokens: (options: BurnTokensOptions) => Promise<BurnTokensResult>
  isLoading: boolean
  error: Error | null
  data: BurnTokensResult | null
  reset: () => void
  
  mintInput: string
  amountInput: string
  decimalsInput: string
  setMintInput: (value: string) => void
  setAmountInput: (value: string) => void
  setDecimalsInput: (value: string) => void
  handleMintInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void
  handleAmountInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void
  handleDecimalsInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void
  handleSubmit: (event?: { preventDefault?: () => void }) => Promise<BurnTokensResult | undefined>
  burnFromInputs: () => Promise<BurnTokensResult | undefined>
}

export function useBurnTokens(
  initialMintInput: string = '',
  initialAmountInput: string = '',
  initialDecimalsInput: string = '9'
): UseBurnTokensReturn {
  const { wallet, network, config } = useArcClient()
  
  const [mintInput, setMintInput] = useState(initialMintInput)
  const [amountInput, setAmountInput] = useState(initialAmountInput)
  const [decimalsInput, setDecimalsInput] = useState(initialDecimalsInput)
  
  const stableOptionsRef = useRef({
    network: network.rpcUrl,
    commitment: config.commitment || 'confirmed',
  })
  
  useEffect(() => {
    stableOptionsRef.current = {
      network: network.rpcUrl,
      commitment: config.commitment || 'confirmed',
    }
  }, [network.rpcUrl, config.commitment])
  
  useEffect(() => {
    return () => {
      releaseRpcConnection(network.rpcUrl)
    }
  }, [network.rpcUrl])
  
  const mutation = useMutation({
    mutationFn: async (options: BurnTokensOptions): Promise<BurnTokensResult> => {
      const { 
        mint, 
        from: optionsFrom, 
        tokenAccount: explicitTokenAccount,
        amount,
        decimals
      } = options
      
      const fromAddress = optionsFrom || wallet.address
      
      if (!fromAddress) {
        throw new Error('No owner address provided and no wallet connected')
      }
      
      if (!wallet.signer) {
        throw new Error('Wallet not connected or no signer available')
      }
      
      console.log('üî• Starting token burning...')
      console.log('üì° RPC URL:', network.rpcUrl)
      console.log('üè¶ Mint:', mint)
      console.log('üì§ From wallet:', fromAddress)
      console.log('üí∞ Amount:', amount.toString())
      console.log('üî¢ Decimals:', decimals)
      
      const rpc = getSharedRpc(network.rpcUrl)
      const rpcSubscriptions = getSharedWebSocket(network.rpcUrl)
      const transport = (useArcClient() as any).config.transport as Transport
      const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc: rpc as any, rpcSubscriptions: rpcSubscriptions as any })
      
      let fromTokenAccount: Address
      
      if (explicitTokenAccount) {
        fromTokenAccount = address(explicitTokenAccount)
        console.log('üéØ Using explicit token account:', fromTokenAccount)
      } else {
        console.log('üîç Finding associated token account...')
        const [ata] = await findAssociatedTokenPda({
          mint: address(mint),
          owner: address(fromAddress),
          tokenProgram: TOKEN_PROGRAM_ADDRESS,
        })
        fromTokenAccount = ata
        console.log('‚úÖ Found associated token account:', fromTokenAccount)
      }
      
      const accountInfo: any = await transport.request(
        { method: 'getAccountInfo', params: [fromTokenAccount] }
      )
      if (!accountInfo.value) {
        throw new Error(`Token account does not exist: ${fromTokenAccount}`)
      }
      
      console.log('‚úÖ Token account verified')
      
      const { value: latestBlockhash }: any = await transport.request(
        { method: 'getLatestBlockhash', params: [] }
      )
      console.log('üîó Latest blockhash:', latestBlockhash.blockhash)
      
      const burnInstruction = getBurnCheckedInstruction({
        account: fromTokenAccount,
        mint: address(mint),
        authority: address(fromAddress),
        amount,
        decimals,
      }, {
        programAddress: TOKEN_PROGRAM_ADDRESS
      })
      
      console.log('üìã Burn instruction created')
      
      const transactionMessage = pipe(
        createTransactionMessage({ version: 0 }),
        tx => setTransactionMessageFeePayerSigner(wallet.signer as TransactionSigner, tx),
        tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
        tx => appendTransactionMessageInstructions([burnInstruction], tx),
      )
      
      console.log('üî® Transaction message built')
      
      const signedTransaction = await signTransactionMessageWithSigners(transactionMessage)
      const signature = getSignatureFromTransaction(signedTransaction)
      
      console.log('üì° Sending transaction, signature:', signature)
      
      await sendAndConfirmTransaction(signedTransaction, { 
        commitment: 'confirmed',
        skipPreflight: false
      })
      
      console.log('‚úÖ Tokens burned successfully!')
      
      const result: BurnTokensResult = {
        signature,
        mint: address(mint),
        amount,
        decimals,
        from: address(fromAddress),
        fromTokenAccount
      }
      
      return result
    },
    onSuccess: (data) => {
      console.log('üéâ Token burning successful:', data)
    },
    onError: (error) => {
      console.error('‚ùå Token burning failed:', error)
    }
  })

  const handleMintInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setMintInput(event.target.value)
  }, [])
  
  const handleAmountInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setAmountInput(event.target.value)
  }, [])

  const handleDecimalsInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setDecimalsInput(event.target.value)
  }, [])
  
  const burnFromInputs = useCallback(async () => {
    if (!mintInput || !amountInput || !decimalsInput) {
      throw new Error('Mint address, amount, and decimals are all required')
    }
    
    try {
      const amountBigInt = BigInt(amountInput)
      const decimals = parseInt(decimalsInput, 10)

      if (isNaN(decimals)) {
        throw new Error('Invalid decimals value')
      }
      
      return await mutation.mutateAsync({
        mint: mintInput,
        amount: amountBigInt,
        decimals,
      })
    } catch (error) {
      console.error('Failed to parse inputs or burn tokens:', error)
      throw error
    }
  }, [mintInput, amountInput, decimalsInput, mutation.mutateAsync])
  
  const handleSubmit = useCallback(async (event?: { preventDefault?: () => void }) => {
    event?.preventDefault?.()
    return mintInput && amountInput && decimalsInput ? burnFromInputs() : undefined
  }, [mintInput, amountInput, decimalsInput, burnFromInputs])

  return {
    burnTokens: mutation.mutateAsync,
    isLoading: mutation.isPending,
    error: mutation.error,
    data: mutation.data || null,
    reset: mutation.reset,
    mintInput,
    amountInput,
    decimalsInput,
    setMintInput,
    setAmountInput,
    setDecimalsInput,
    handleMintInputChange,
    handleAmountInputChange,
    handleDecimalsInputChange,
    handleSubmit,
    burnFromInputs,
  }
}
```

## Parameters

The hook accepts optional initial values for the form inputs:
- `initialMintInput?: string` - Initial mint address value (default: '')
- `initialAmountInput?: string` - Initial amount value (default: '')
- `initialDecimalsInput?: string` - Initial decimals value (default: '9')

## BurnTokensOptions

- `mint: string | Address` - The mint address of the token to burn
- `from?: string | Address` - The owner address (defaults to connected wallet)
- `tokenAccount?: string | Address` - Specific token account to burn from (optional, uses ATA if not provided)
- `amount: bigint` - The amount to burn (in raw token units)
- `decimals: number` - The number of decimal places for the token

## Return Value

- `burnTokens: (options: BurnTokensOptions) => Promise<BurnTokensResult>` - Function to burn tokens
- `isLoading: boolean` - Whether the burn operation is in progress
- `error: Error | null` - Any error that occurred
- `data: BurnTokensResult | null` - Result of the successful burn operation
- `reset: () => void` - Function to reset the mutation state

**Form Management:**
- `mintInput: string` - Current mint input value
- `amountInput: string` - Current amount input value
- `decimalsInput: string` - Current decimals input value
- `setMintInput: (value: string) => void` - Set mint input value
- `setAmountInput: (value: string) => void` - Set amount input value
- `setDecimalsInput: (value: string) => void` - Set decimals input value
- `handleMintInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void` - Mint input change handler
- `handleAmountInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void` - Amount input change handler
- `handleDecimalsInputChange: (event: React.ChangeEvent<HTMLInputElement>) => void` - Decimals input change handler
- `handleSubmit: (event?: { preventDefault?: () => void }) => Promise<BurnTokensResult | undefined>` - Form submit handler
- `burnFromInputs: () => Promise<BurnTokensResult | undefined>` - Burn using current input values

## Example

```tsx
import { useBurnTokens } from '@arc/solana'
import { useMint } from '@arc/solana'
import { useTokenBalance } from '@arc/solana'

function BurnTokensInterface() {
  const {
    burnTokens,
    isLoading,
    error,
    data,
    reset,
    mintInput,
    amountInput,
    decimalsInput,
    setMintInput,
    setAmountInput,
    setDecimalsInput,
    handleSubmit
  } = useBurnTokens()

  const { mint } = useMint({ mintAddress: mintInput })
  const { balance } = useTokenBalance({ mint: mintInput })

  const formatAmount = (rawAmount: string) => {
    if (!rawAmount || !mint) return rawAmount
    const amount = BigInt(rawAmount)
    const divisor = BigInt(10 ** mint.decimals)
    const formatted = Number(amount) / Number(divisor)
    return formatted.toString()
  }

  // Auto-populate decimals when mint is loaded
  useEffect(() => {
    if (mint && mint.decimals && decimalsInput === '9') {
      setDecimalsInput(mint.decimals.toString())
    }
  }, [mint, decimalsInput, setDecimalsInput])

  return (
    <div style={{ padding: '20px', maxWidth: '500px' }}>
      <h3>Burn Tokens</h3>
      
      <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
        <div>
          <label>Mint Address:</label>
          <input
            type="text"
            value={mintInput}
            onChange={(e) => setMintInput(e.target.value)}
            placeholder="Enter mint address"
            style={{ width: '100%', padding: '8px', marginTop: '4px' }}
          />
          {balance && (
            <small style={{ color: '#666' }}>
              Available balance: {formatAmount(balance.amount.toString())} tokens
            </small>
          )}
        </div>

        <div>
          <label>
            Amount (raw units)
            {mint && ` - ${formatAmount(amountInput)} tokens with ${mint.decimals} decimals`}:
          </label>
          <input
            type="text"
            value={amountInput}
            onChange={(e) => setAmountInput(e.target.value)}
            placeholder="Enter amount in raw units"
            style={{ width: '100%', padding: '8px', marginTop: '4px' }}
          />
          {mint && (
            <small style={{ color: '#666' }}>
              For {mint.decimals} decimals, 1 token = {(10 ** mint.decimals).toLocaleString()} raw units
            </small>
          )}
        </div>

        <div>
          <label>Decimals:</label>
          <input
            type="number"
            value={decimalsInput}
            onChange={(e) => setDecimalsInput(e.target.value)}
            placeholder="Token decimals"
            style={{ width: '100%', padding: '8px', marginTop: '4px' }}
          />
          {mint && mint.decimals && (
            <small style={{ color: '#666' }}>
              Detected decimals from mint: {mint.decimals}
            </small>
          )}
        </div>

        <button
          type="submit"
          disabled={isLoading || !mintInput || !amountInput || !decimalsInput}
          style={{
            padding: '12px',
            backgroundColor: isLoading ? '#ccc' : '#f44336',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: isLoading ? 'not-allowed' : 'pointer'
          }}
        >
          {isLoading ? 'Burning...' : 'Burn Tokens'}
        </button>
      </form>

      {error && (
        <div style={{ 
          marginTop: '16px', 
          padding: '12px', 
          backgroundColor: '#ffebee', 
          border: '1px solid #f44336',
          borderRadius: '4px',
          color: '#d32f2f'
        }}>
          <strong>Error:</strong> {error.message}
          <button 
            onClick={reset}
            style={{ marginLeft: '8px', padding: '4px 8px' }}
          >
            Clear
          </button>
        </div>
      )}

      {data && (
        <div style={{ 
          marginTop: '16px', 
          padding: '12px', 
          backgroundColor: '#fff3e0', 
          border: '1px solid '#ff9800',
          borderRadius: '4px'
        }}>
          <h4>Burn Successful!</h4>
          <p><strong>Signature:</strong> 
            <a 
              href={`https://explorer.solana.com/tx/${data.signature}`}
              target="_blank"
              rel="noopener noreferrer"
              style={{ marginLeft: '8px', color: '#1976d2' }}
            >
              {data.signature.slice(0, 8)}...
            </a>
          </p>
          <p><strong>Amount Burned:</strong> {data.amount.toString()}</p>
          <p><strong>From Account:</strong> {data.fromTokenAccount}</p>
          <p><strong>Decimals:</strong> {data.decimals}</p>
        </div>
      )}
    </div>
  )
}
```

## Features

- **Automatic Token Account Resolution**: Finds associated token accounts automatically
- **Decimals Validation**: Uses burn checked instruction for safety
- **Form Input Management**: Built-in form state management with change handlers
- **Account Verification**: Verifies token account exists before burning
- **Detailed Logging**: Comprehensive console logging for debugging

## Use Cases

- **Token Supply Reduction**: Permanently remove tokens from circulation
- **Deflationary Mechanisms**: Implement token burning for deflationary tokenomics
- **Cleanup Operations**: Remove unwanted or mistaken token balances
- **Testing**: Burn test tokens during development

## Notes

- Requires the connected wallet to own the tokens being burned
- Burns tokens from the associated token account by default
- The amount should be provided in raw token units (considering decimals)
- Uses `getBurnCheckedInstruction` for safety, which validates the decimals parameter
- Transaction fees are paid by the connected wallet
- Burned tokens are permanently removed from circulation